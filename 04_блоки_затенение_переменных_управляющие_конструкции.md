Переменная является затеняющей, если ее имя совпадает с именем переменной, определенной во вмещающем блоке.

Линтер shadow помогает выявить наличие затененных переменных.

``` go
fmt.Println(true)
true := 10
fmt.Println(true)
```
Запустив этот код, вы увидите на экране следующее:
true
10

Типы (такие как int и string), константы (true и false), функции (make и close) и значение nil - в Go это не ключевые слова, а предопределенные идентификаторы и определено во всеобщем блоке, включающем в себя все остальные блоки.
Никогда не допускайте переопределения идентификаторов, определенных во всеобщем блоке! 
Даже линтер shadow не выявляет затенение идентификаторов, объявленных во всеобщем блоке.

ОПЕРАТОР IF
``` go
n := rand.Intn(10)
if n == 0 {
  fmt.Println("That's too low")
} else if n > 5 {
  fmt.Println("That's too big:", n)
} else {
  fmt.Println("That's a good number:", n)
}
```
или объявление переменной внутри оператора if (те n областьвидимости внутри if и это правильно, области видимости нужно сокращать)
``` go
if n := rand.Intn(10); n == 0 {
  fmt.Println("That's too low")
} else if n > 5 {
  fmt.Println("That's too big:", n)
} else {
  fmt.Println("That's a good number:", n)
}
```
Полный оператор for
``` go
for i := 0; i < 10; i++ {
  fmt.Println(i)
}
```
Первое выражение представляет собой выражение инициализации, которое присваивает значения одной или нескольким переменным перед выполнением цикла.
Второе выражение представляет собой выражение сравнения, которое должно давать в результате логическое значение. Результат этого выражения проверяется непосредственно перед выполнением тела цикла, после выполнения инициализации и после выполнения каждой итерации. Тело цикла выполняется, если результат этого выражения равен true.
Последнее выражение стандартного оператора for представляет собой вы­ражение инкремента. Обычно здесь стоит что-то вроде i++ , но вы можете использовать здесь любую операцию присваивания. Это выражение выпол­
няется непосредственно после каждой итерации цикла, перед проверкой условия.

Оператор for, использующий только условие
``` go
i := 1
for i < 100 {
  fmt.Println(i)
  i = i * 2
}
```
Бесконечный оператор for
``` go
for {
  fmt.Println("Hello")
}
```

Ключевые слова break и continue
``` go
for {
  // действия, выполняемые в цикле
  if !CONDITION {
    break // ПРЕРВАТЬ ЦИКЛ
  }
}
```
``` go
for i := 1; i <= 100; i++ {
  if i%3 == 0 && i%5 == 0 {
    fmt.Println("FizzBuzz")
    continue  // пропускаем текущую итерацию и переходим к следующей
  }
  fmt.Println(i)
}
```
Оператор for-range используется для обхода строк, массивов, срезов и карт (и чтения из каналов). 
``` go
evenVals := []int{2, 4, 6, 8, 10, 12}
for i, v := range evenVals {  // for range работает с копией evenVals 
  fmt.Println(i, v)
}
```
Выбор идиоматических имен для этих переменных зависит от того, что именно обрабатывается в цикле. В случае массива, среза или строки индексы принято
обозначать буквой i. При обработке карты вместо нее используется буква k, которая подразумевает ключи.

Второй переменной обычно дают имя v, что означает value — «значение», однако иногда ей присваивают имя, основанное на типе перебираемых значений.

``` go
evenVals := []int{2, 4, 6, 8, 10, 12}
for _, v := range evenVals {
  fmt.Println(v)
}
```
Если вам не нужно использовать ключи, поставьте вместо имени переменной символ подчеркивания (_).

``` go
uniqueNames := map[string]bool{"Fred": true, "Raul": true, "Wilma": true}
for k := range uniqueNames {
  fmt.Println(k)
}
```
Если нужны только ключи
``` go
m := map[string]int{
  "a": 1,
  "c": 3,
  "b": 2,
}
for i := 0; i < 3; i++ {
  fmt.Println("Loop", i)
  for k, v := range m {
    fmt.Println(k, v)
  }
}
```
Обход элементов карты (вывод будет меняться!!! порядок недетерминирован - это обусловлено соображениями безопасности) 

Обход элементов строки
``` go
samples := []string{"hello", "apple_π!"}
for _, sample := range samples {
  for i, r := range sample {
    fmt.Println(i, r, string(r))
  }
  fmt.Println()
}
```
**range** возращает руны  (Этот цикл перебирает руны) - числовое значение буквы
Всякий раз, когда цикл for-range встречает в строке руну из нескольких байтов, он преобразует это представление в формате UTF-8 в одно 32-разрядное число и присваивает его переменной. Смещение при этом увеличивается на то количество байтов, которое содержится в руне.

Цикл for-range копирует значения элементов

``` go
evenVals := []int{2, 4, 6, 8, 10, 12}
for _, v := range evenVals {
  v *= 2
}
fmt.Println(evenVals)
```
Этот код выведет следующее:
[2 4 6 8 10 12]
при обходе любого составного типа цикл for-range копирует значение из этого составного типа в значение переменной. Изменение значения переменной не приведет к изменению соответствующего значения
в составном типе.

Оператор for-range позволяет использовать ключевые слова break и continue  и распространяется на тот цикл for, который непосредственно их содержит.

Операторы for с **метками**.

``` go
samples := []string{"hello", "apple_π!"}
outer:
for _, sample := range samples {
  for i, r := range sample {
    fmt.Println(i, r, string(r))
    if r == 'l' {
      continue outer   // или break outer
    }
  }
  fmt.Println()
}
```
Тут происходит выход из всех циклов.


Оператор **switch**.

``` go
words := []string{"a", "cow", "smile", "gopher", "octopus", "anthropologist"}
for _, word := range words {
  switch size := len(word); size {
    case 1, 2, 3, 4:
      fmt.Println(word, "is a short word!")
    case 5:
      wordLen := len(word)
    fmt.Println(word, "is exactly the right length:", wordLen)
      case 6, 7, 8, 9:
    default:
      fmt.Println(word, "is a long word!")
  }
}
```

В языке Go есть ключевое слово **fallthrough**, которое позволяет перейти в следующую ветвь после выполнения текущей ветви.

``` go
loop:
for i := 0; i < 10; i++ {
  switch {
    case i%2 == 0:
      fmt.Println(i, "is even")
    case i%3 == 0:
      fmt.Println(i, "is divisible by 3 but not 2")
    case i%7 == 0:
      fmt.Println("exit the loop!")
      break  loop
    default:
      fmt.Println(i, "is boring")
  }
}
```

Если оператор switch вложен в цикл for и вам нужно выйти из этого цикла, снабдите меткой цикл for и укажите эту метку в операторе break. 


Пустые переключатели.

``` go
words := []string{"hi", "salutations", "hello"}
for _, word := range words {
  switch wordLen := len(word); {
    case wordLen < 5:
      fmt.Println(word, "is a short word!")
    case wordLen > 10:
      fmt.Println(word, "is a long word!")
    default:
      fmt.Println(word, "is exactly the right length.")
  }
}
```

пустой оператор switch позволяет использовать для каждой ветви case любую операцию сравнения, дающую в результате логическое значение.

Оператор **goto**.

goto skip

skip:

Так когда же использовать оператор goto? Обычно никогда! 
