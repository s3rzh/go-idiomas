Чтобы выполнять какую-то полезную работу, программа должна читать и запи­сывать данные. Основные принципы работы с вводом/выводом в Go нашли свое выражение в пакете io . В частности, в нем определены два интерфейса: io.Reader и io.Writer.
``` go
type Reader interface {
  Read(p []byte) (n int, err error)
}

type Writer interface {
  Write(p []byte) (n int, err error)
}
```
Метод Write интерфейса io.Writer принимает срез байтов, которые требуется записать, и возвращает количество записанных байтов и ошибку в случае воз­никновения проблем. Метод Read интерфейса io.Reader вместо возврата данных через возвращаемое значение модифицирует срез, получен­ный во входном параметре. В срез записывается до len(p) байт. А в возвращае­мом значении метод Read сообщает количество прочитанных байтов.
В пакет io включена и стандартная функция io.Copy, копирующая данные из эк­земпляра интерфейса io.Reader в экземпляр интерфейса io.Writer.
Другие стандартные функции из пакета io, расширяющие возможности экземпляров интерфейсов io.Reader и io.Writer:
- io.MultiReader — возвращает экземпляр интерфейса io.Reader, выполняющий последовательное чтение из нескольких экземпляров io.Reader;
- io.LimitReader — возвращает экземпляр интерфейса io.Reader, читающий не более указанного количества байтов из предоставленного экземпляра io.Reader;
- io.MultiWriter — возвращает экземпляр интерфейса io.Writer, выполняющий запись сразу в несколько экземпляров io.Writer.
Ещё интерфейсы, в частности io.Closer и io.Seeker:
``` go
type Closer interface {
  Close() error
}

type Seeker interface {
  Seek(offset int64, whence int) (int64, error)
}
```
Интерфейс io.Closer реализуется такими типами, как os.File, которым нужно высвобождать ресурсы после завершения чтения или записи. Обычно метод Close вызывается с помощью оператора defer:
``` go
f, err := os.Open(fileName)
if err != nil {
  return nil, err
}
defer f.Close()
// использование экземпляра f
```
Не применяйте оператор defer, когда ресурс открывается в цикле, поскольку он вызывается лишь в момент закрытия функции. Вместо этого вызывайте метод Close в конце каждой итерации цикла. В случае возникновения ошибок, ведущих к выходу из цикла, также следует вызывать метод Close.
Интерфейс io.Seeker используется для произвольного доступа к ресурсу. В каче­стве параметра whence могут применяться константы io.SeekStart, io.SeekCurrent и io.SeekEnd.
