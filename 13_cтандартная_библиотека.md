Чтобы выполнять какую-то полезную работу, программа должна читать и запи­сывать данные. Основные принципы работы с вводом/выводом в Go нашли свое выражение в пакете io . В частности, в нем определены два интерфейса: io.Reader и io.Writer.
``` go
type Reader interface {
  Read(p []byte) (n int, err error)
}

type Writer interface {
  Write(p []byte) (n int, err error)
}
```
Метод Write интерфейса io.Writer принимает срез байтов, которые требуется записать, и возвращает количество записанных байтов и ошибку в случае воз­никновения проблем. Метод Read интерфейса io.Reader вместо возврата данных через возвращаемое значение модифицирует срез, получен­ный во входном параметре. В срез записывается до len(p) байт. А в возвращае­мом значении метод Read сообщает количество прочитанных байтов.
В пакет io включена и стандартная функция io.Copy, копирующая данные из эк­земпляра интерфейса io.Reader в экземпляр интерфейса io.Writer.
Другие стандартные функции из пакета io, расширяющие возможности экземпляров интерфейсов io.Reader и io.Writer:
- io.MultiReader — возвращает экземпляр интерфейса io.Reader, выполняющий последовательное чтение из нескольких экземпляров io.Reader;
- io.LimitReader — возвращает экземпляр интерфейса io.Reader, читающий не более указанного количества байтов из предоставленного экземпляра io.Reader;
- io.MultiWriter — возвращает экземпляр интерфейса io.Writer, выполняющий запись сразу в несколько экземпляров io.Writer.
Ещё интерфейсы, в частности io.Closer и io.Seeker:
``` go
type Closer interface {
  Close() error
}

type Seeker interface {
  Seek(offset int64, whence int) (int64, error)
}
```
Интерфейс io.Closer реализуется такими типами, как os.File, которым нужно высвобождать ресурсы после завершения чтения или записи. Обычно метод Close вызывается с помощью оператора defer:
``` go
f, err := os.Open(fileName)
if err != nil {
  return nil, err
}
defer f.Close()
// использование экземпляра f
```
Не применяйте оператор defer, когда ресурс открывается в цикле, поскольку он вызывается лишь в момент закрытия функции. Вместо этого вызывайте метод Close в конце каждой итерации цикла. В случае возникновения ошибок, ведущих к выходу из цикла, также следует вызывать метод Close.

Интерфейс io.Seeker используется для произвольного доступа к ресурсу. В каче­стве параметра whence могут применяться константы io.SeekStart, io.SeekCurrent и io.SeekEnd.
В пакете io также определены интерфейсы, позволяющие применять различ­ные комбинации этих четырех интерфейсов: io.ReadCloser, io.ReadSeeker, io.ReadWriteCloser , io.ReadWriteSeeker , io.ReadWriter , io.WriteCloser и io.WriteSeeker. Например, вместо простой передачи параметра типа os.File можно использовать интерфейсы, указывающие, что именно функция будет де­лать с параметром. Так вы не только сделаете функции более универсальными, но и понятнее выразите свои намерения. Совместимость с этими интерфейсами следует обеспечить и при создании источников и приемников данных. При создании собственных интерфейсов старайтесь делать их столь же простымии несвязанными, как интерфейсы пакета io, которые наглядно демонстрируют, какие мощные возможности могут давать простые абстракции.

Помимо интерфейсов, в пакете io имеется несколько вспомогательных функций для выполнения типичных операций. Например, io.ReadAll читает все данные из io.Reader в срез байтов. Одна из наиболее удачных функций в io демонстри­рует паттерн добавления метода в тип языка Go. Если у вас есть тип, который реализует интерфейс io.Reader, но не реализует интерфейс io.Closer (как, например, тип strings.Reader), и вам нужно передать его в функцию, ожидающую экземпляр интерфейса io.ReadCloser, передайте свой экземпляр интерфейса io.Reader в функцию io.NopCloser, чтобы получить тип, реализующий интер­фейс io.ReadCloser. Заглянув в реализацию этой функции, вы увидите, что она очень простая:
``` go
type nopCloser struct {
  io.Reader
}

func (nopCloser) Close() error { return nil }

func NopCloser(r io.Reader) io.ReadCloser {
  return nopCloser{r}
}
```
Всякий раз, когда нужно снабдить определенный тип методами так, чтобы он соответствовал некоторому интерфейсу, используйте этот паттерн встроенного типа.

Функция io.NopCloser нарушает общее правило, согласно которому вы не должны возвращать интерфейс из функции, но это простой адаптер интер­фейса, который гарантированно останется неизменным, поскольку является
составной частью стандартной библиотеки.


