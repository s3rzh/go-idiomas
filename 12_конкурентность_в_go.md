Модель конкурентности языка Go основана на теории взаимодействующих последовательных процессов (Communicating Sequential Processes, CSP).

Применяйте конку­рентность лишь в том случае, когда она делает вашу программу лучше.

**Конкурентность** — это не **параллелизм**.

Будет или нет конкурентный код выполняться параллельно (одновременно), за­висит от используемого аппаратного обеспечения и от того, позволяет ли это алго­ритм.

Процесс выполнения любой программы можно разделить на три этапа: *получение данных*, их *преобразование* и *вывод результата*. Ответ на вопрос, следует или нет использовать в программе конку­
рентность, зависит от того, как движутся данные в программе по мере выпол­нения этих этапов. Иногда два этапа могут выполняться конкурентно, потому что результаты одного этапа не требуются для выполнения другого, а иногда два этапа должны выполняться последовательно, потому что результаты одного этапа необходимы для выполнения другого. Применяйте конкурентность, когда
требуется объединить результаты нескольких операций, которые могут выпол­няться независимо друг от друга.

Конкурентность не стоит использовать в тех случаях, когда выполнение процессов не занимает много времени. Помните о том, что конкурентность несет за собой определенные издержки. Многие реализации
известных алгоритмов, работающих в памяти, выполняются настолько быстро, что накладные расходы на передачу значений посредством конкурентности пере­вешивают любую потенциальную экономию за счет параллельного выполнения конкурентного кода. Именно поэтому конкурентность часто используется при выполнении операций ввода-вывода: операции чтения или записи на диск или в сеть работают в тысячи раз медленнее операций с памятью, кроме самых слож­ных. 

**Процесс** — это экземпляр программы, выполняемой опера­ционной системой компьютера.  Операционная система связывает с процессом такие ресурсы, как память, и следит за тем, чтобы другие процессы не могли их (те ресурсы) использовать. Процесс состоит из одного или нескольких потоков. **Поток** — это единица выполнения, на работу которой операционная система дает некоторое время. Потоки одного процесса совместно используют его ресурсы (те память). Центральный процессор может выполнять инструкции из одного или нескольких потоков одно­временно в зависимости от количества имеющихся у него ядер. Одной из задач операционной системы является планирование выполнения потоков процессором таким образом, чтобы были выполнены каждый процесс и каждый его поток.

**Горутины** — ключевая концепция модели конкурентности языка Go.
*Горутины* — это легковесные потоки, которыми распоряжается среда выполнения языка Go. При запуске Go-программы среда выполнения языка Go создает для нее несколько потоков и запускает одну горутину. Все создаваемые go-программой горутины, включая самую первую, автоматически закрепляются за этими пото­ками планировщиком среды выполнения языка Go.

Преимущества использования горутин:
1. Создание горутины занимает меньше времени, чем создание потока, поскольку при этом не создается системный ресурс.
2. Исходный размер стека горутин (2 KB) меньше размера стека потоков и может увели­чиваться/уменьшаться по мере необходимости. Это делает горутины более эффективными в плане использования памяти.
3. Переключение между горутинами занимает меньше времени, чем переключе­ние между потоками, поскольку осуществляется полностью внутри процесса, без обращений к сравнительно медленным системным вызовам.
4. Являясь составной частью процесса, планировщик может оптимизировать свои решения. Взаимодействуя с механизмом опроса сетевых соединений, планировщик выявляет горутины, заблокированные в операции ввода-вывода, и не планирует их на выполнение. Он также взаимодействует со сборщиком мусора и следит за тем, чтобы работа была равномерно распределена между потоками операционной системы, выделенными для вашего Go-процесса.

Эти преимущества позволяют Go-программам создавать сотни, тысячи и даже десятки тысяч одновременных горутин. 

Горутине можно передать параметры для инициали­зации ее состояния, но ее возвращаемые значения будут игнорироваться.
Горутины принято запускать с помощью замыкания.
Горутины общаются друг с другом посредством каналов. каналы представляют собой ссылочный тип. Когда вы передаете канал функции, ей в действительности передается указатель на канал. Нулевым значением для каналов является значение nil. Значение, записанное в канал, можно прочитать только один раз. Если данные из канала читают несколько горутин, то записанное в него значение прочитает
только одна из них.

По умолчанию каналы являются небуферизованными. После каждой операции записи в открытый небуферизованный канал пишущая горутина приостанав­ливается (те даже не выполняет свой код, который следует после отправки), пока другая горутина не прочитает данные из этого канала. Точно так же после каждой операции чтения из открытого небуферизованного канала читающая горутина приостанавливается, пока другая горутина не запишет новое значение в него. При использовании небуферизованного канала требуются как минимум две параллельно работающие горутины.
Буферизованные каналы, которые буферизуют без блокировки некоторое ограниченное количество операций записи. Если буфер заполнится до выполнения каких-либо операций чтения из канала, то следую­
щая операция записи в этот канал приостановит записывающую горутину, пока не будет произведено чтение из канала. Точно так же попытка чтения из канала с пустым буфером приостановит читающую горутину.

Встроенные функции **len** и **cap** возвращают информацию о буферизованном канале. С помощью функции len можно узнать текущее количество значений в буфере, с помощью cap — максимальный размер буфера, или его емкость. Емкость буфера нельзя изменить. При передаче небуферизованного канала функции len и cap возвращают 0. логично, тк нет буфера.

Для чтения из канала можно задействовать цикл for-range:
``` go
for v := range ch {
  fmt.Println(v)
}
```
В отличие от других вариантов использования цикла for-range, в данном случае для канала объявляется только одна переменная, представляющая содержащиеся в нем значения. Если канал открыт и в нем доступно значение, оно присваивается переменной v и затем выполняется тело цикла. Если в канале нет значения, то горутина приостанавливается, пока значение не станет доступным или канал
не будет закрыт. Выполнение цикла продолжается до тех пор, пока канал не будет закрыт или не будет встречен оператор break или return.

После завершения записи в канал его следует закрыть вызовом встроенной функции close:
``` go
  close(ch)
```
После закрытия канала любые попытки произвести в него запись или закрыть его снова приведут к панике. Однако, что интересно, попытки чтения из закрытого канала всегда завершаются успехом. Если канал буферизованный и в буфере остаются непрочитанные значения, то они будут возвращены в том же порядке, в каком были записаны. Если канал небуферизованный или буферизованный, но
с пустым буфером, то операция чтения вернет нулевое значение, соответствующее типу канала (например 0 для int, или false для bool).

Использование идиомы «запятая-ok» для проверки того, закрыт канал или нет:
``` go
v, ok := <-ch
```
Если переменная ok получит значение true, значит, канал открыт. Если пере­менная ok получит значение false — закрыт. Производя чтение из канала, который может оказаться закрытым, всегда
используйте идиому «запятая-ok», чтобы убедиться в том, что канал еще открыт.
Задача закрытия канала возлагается на горутину, которая пишет в канал.

Поскольку каналы — всего лишь одна из разновидностей переменных, среда выполнения языка Go может выявлять неиспользуемые каналы и удалять их путем сборки мусора.




