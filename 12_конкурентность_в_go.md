Модель конкурентности языка Go основана на теории взаимодействующих последовательных процессов (Communicating Sequential Processes, CSP).

Применяйте конку­рентность лишь в том случае, когда она делает вашу программу лучше.

**Конкурентность** — это не **параллелизм**.

Будет или нет конкурентный код выполняться параллельно (одновременно), за­висит от используемого аппаратного обеспечения и от того, позволяет ли это алго­ритм.

Процесс выполнения любой программы можно разделить на три этапа: *получение данных*, их *преобразование* и *вывод результата*. Ответ на вопрос, следует или нет использовать в программе конкурентность, зависит от того, как движутся данные в программе по мере выпол­нения этих этапов. Иногда два этапа могут выполняться конкурентно, потому что результаты одного этапа не требуются для выполнения другого, а иногда два этапа должны выполняться последовательно, потому что результаты одного этапа необходимы для выполнения другого. Применяйте конкурентность, когда
требуется объединить результаты нескольких операций, которые могут выпол­няться независимо друг от друга.

Конкурентность не стоит использовать в тех случаях, когда выполнение процессов не занимает много времени. Помните о том, что конкурентность несет за собой определенные издержки. Многие реализации
известных алгоритмов, работающих в памяти, выполняются настолько быстро, что накладные расходы на передачу значений посредством конкурентности пере­вешивают любую потенциальную экономию за счет параллельного выполнения конкурентного кода. Именно поэтому конкурентность часто используется при выполнении операций ввода-вывода: операции чтения или записи на диск или в сеть работают в тысячи раз медленнее операций с памятью, кроме самых слож­ных. 

**Процесс** — это экземпляр программы, выполняемой опера­ционной системой компьютера.  Операционная система связывает с процессом такие ресурсы, как память, и следит за тем, чтобы другие процессы не могли их (те ресурсы) использовать. Процесс состоит из одного или нескольких потоков. **Поток** — это единица выполнения, на работу которой операционная система дает некоторое время. Потоки одного процесса совместно используют его ресурсы (те память). Центральный процессор может выполнять инструкции из одного или нескольких потоков одно­временно в зависимости от количества имеющихся у него ядер. Одной из задач операционной системы является планирование выполнения потоков процессором таким образом, чтобы были выполнены каждый процесс и каждый его поток.

**Горутины** — ключевая концепция модели конкурентности языка Go.
*Горутины* — это легковесные потоки, которыми распоряжается среда выполнения языка Go. При запуске Go-программы среда выполнения языка Go создает для нее несколько потоков и запускает одну горутину. Все создаваемые go-программой горутины, включая самую первую, автоматически закрепляются за этими пото­ками планировщиком среды выполнения языка Go.

Функция **main** сама выполняется в горутине, которая запуска­ется средой выполнения языка Go при запуске программы.

Преимущества использования горутин:
1. Создание горутины занимает меньше времени, чем создание потока, поскольку при этом не создается системный ресурс.
2. Исходный размер стека горутин (2 KB) меньше размера стека потоков и может увели­чиваться/уменьшаться по мере необходимости. Это делает горутины более эффективными в плане использования памяти.
3. Переключение между горутинами занимает меньше времени, чем переключе­ние между потоками, поскольку осуществляется полностью внутри процесса, без обращений к сравнительно медленным системным вызовам.
4. Являясь составной частью процесса, планировщик может оптимизировать свои решения. Взаимодействуя с механизмом опроса сетевых соединений, планировщик выявляет горутины, заблокированные в операции ввода-вывода, и не планирует их на выполнение. Он также взаимодействует со сборщиком мусора и следит за тем, чтобы работа была равномерно распределена между потоками операционной системы, выделенными для вашего Go-процесса.

Эти преимущества позволяют Go-программам создавать сотни, тысячи и даже десятки тысяч одновременных горутин. 

Горутине можно передать параметры для инициали­зации ее состояния, но ее возвращаемые значения будут игнорироваться.
Горутины принято запускать с помощью замыкания.
Горутины общаются друг с другом посредством каналов. каналы представляют собой ссылочный тип. Когда вы передаете канал функции, ей в действительности передается указатель на канал. Нулевым значением для каналов является значение nil. Значение, записанное в канал, можно прочитать только один раз. Если данные из канала читают несколько горутин, то записанное в него значение прочитает
только одна из них.

По умолчанию каналы являются небуферизованными. После каждой операции записи в открытый небуферизованный канал пишущая горутина приостанав­ливается (те даже не выполняет свой код, который следует после отправки), пока другая горутина не прочитает данные из этого канала. Точно так же после каждой операции чтения из открытого небуферизованного канала читающая горутина приостанавливается, пока другая горутина не запишет новое значение в него. При использовании небуферизованного канала требуются как минимум две параллельно работающие горутины.
Буферизованные каналы, которые буферизуют без блокировки некоторое ограниченное количество операций записи. Если буфер заполнится до выполнения каких-либо операций чтения из канала, то следую­щая операция записи в этот канал приостановит записывающую горутину, пока не будет произведено чтение из канала. Точно так же попытка чтения из канала с пустым буфером приостановит читающую горутину.

Встроенные функции **len** и **cap** возвращают информацию о буферизованном канале. С помощью функции len можно узнать текущее количество значений в буфере, с помощью cap — максимальный размер буфера, или его емкость. Емкость буфера нельзя изменить. При передаче небуферизованного канала функции len и cap возвращают 0. логично, тк нет буфера.

Для чтения из канала можно задействовать цикл for-range:
``` go
for v := range ch {
  fmt.Println(v)
}
```
В отличие от других вариантов использования цикла for-range, в данном случае для канала объявляется только одна переменная, представляющая содержащиеся в нем значения. Если канал открыт и в нем доступно значение, оно присваивается переменной v и затем выполняется тело цикла. Если в канале нет значения, то горутина приостанавливается, пока значение не станет доступным или канал
не будет закрыт. Выполнение цикла продолжается до тех пор, пока канал не будет закрыт или не будет встречен оператор break или return.

После завершения записи в канал его следует закрыть вызовом встроенной функции close:
``` go
  close(ch)
```
После закрытия канала любые попытки произвести в него запись или закрыть его снова приведут к панике. Однако, что интересно, попытки чтения из закрытого канала всегда завершаются успехом (те вернётся нулевое значение). Если канал буферизованный и в буфере остаются непрочитанные значения, то они будут возвращены в том же порядке, в каком были записаны. Если канал небуферизованный или буферизованный, но
с пустым буфером, то операция чтения вернет нулевое значение, соответствующее типу канала (например 0 для int, или false для bool).

Использование идиомы «запятая-ok» для проверки того, закрыт канал или нет:
``` go
v, ok := <-ch
```
Если переменная ok получит значение true, значит, канал открыт. Если пере­менная ok получит значение false — закрыт. Производя чтение из канала, который может оказаться закрытым, всегда
используйте идиому «запятая-ok», чтобы убедиться в том, что канал еще открыт.
Задача закрытия канала возлагается на горутину, которая пишет в канал.

Поскольку каналы — всего лишь одна из разновидностей переменных, среда выполнения языка Go может выявлять неиспользуемые каналы и удалять их путем сборки мусора.
![chan state](images/chan-state.png)

Оператор **select** - позволяет изящно решить, какую из двух конкурентных опера­ций выполнить первой, когда нельзя сделать какую-либо из них более приоритет­ной, чтобы избежать проблемы невыполнения некоторых операций. Проблема, когда какие-то операции не выполняются, потому что постоянно предпочтение отдается более приоритетным операциям, называется голоданием.
Оператор select позволяет горутине произвести чтение или запись в один из нескольких каналов (при готовности нескольких ветвей case - выбор происходит случайным образом). Оператор select может иметь ветвь default эта ветвь выбирается, когда ни с одним из каналов, указанных в ветвях case, не могут быть выполнены операции чтения или записи.

Конкурентности не должно было в API. Это позволяет вносить изменения в работу кода, не изменяя способа его вызова. никогда не следует раскрывать применение каналов или мьютексов  в сигнатурах функций и методов
API. Вынуждая пользователей вашего API передавать или принимать каналы, вы тем самым возлагаете на них ответственность за управление каналами. Это значит, что пользователям придется побеспокоиться о буферизации каналов, их закрытии и правильной обработке каналов nil . Они также могут вызвать состояние взаимоблокировки, попытавшись выполнить доступ к каналам или мьютексам в неожиданном порядке. Они не должны быть экспортируемыми. У этого правила есть исключения. Каналы могут входить в состав API, если речь идет о библиотеке, содержащей вспомогательную функцию для работы с конку­рентностью.

Каждый раз, когда замыкание зависит от переменной, значение которой может измениться независимо от того, используется ли оно в горутине, явно передавайте значение в замыкание или создавайте уникальную копию переменной для каждого замы­кания, которое ссылается на нее.
``` go
go func(val int) {
  _ = val
}(v)
```
Предусматривая запуск горутин, предусматривайте и их завершение. В отличие от переменных, среда выполнения языка Go не может проверить, будет ли еще приме­няться та или иная горутина. Если горутину не закрыть, то планировщик продолжит выделять ей время, которое она не будет использовать, что негативно скажется на производительности программы. Эта проблема называется *утечкой горутин*.
В общем случае выходить из горутины следует после того, как будут использованы все значения. Однако, если выйти из цикла слишком рано, то горутина заблокируется и будет бесконечно ждать, когда из канала будет прочитано еще одно значение:
``` go
func countTo(max int) <-chan int {
	ch := make(chan int)
	go func() {
		for i := 0; i < max; i++ {
			ch <- i // ожидание тут
		}
		close(ch)
	}()
	return ch
}

func main() {
	for i := range countTo(10) {
		if i > 5 { // горутина так и продолжает ждать прочтение остальных значений...
			break
		}
		fmt.Println(i)
	}
}
```

Использование контекста для завершения горутин:
``` go
func countTo(ctx context.Context, max int) <-chan int {
	ch := make(chan int)
	go func() {
		defer close(ch)
		for i := 0; i < max; i++ {
			select {
			case <-ctx.Done():
				return
			case ch <- i:
			}
		}
	}()
	return ch
}

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	ch := countTo(ctx, 10)
	for i := range ch {
		if i > 5 {
			break
		}
		fmt.Println(i)
	}
}
```
Буферизованные каналы следует использовать, когда вы знаете количество запущенных горутин и хотите ограничить количество горутин, которые еще будут запущены, или ограничить объем работы, стоящей в очереди на выполнение. Буферизованные каналы отлично работают, когда нужно либо собрать данные из некоторого набора запущенных горутин, либо ограничить конкурентное ис­пользование. Их можно применять также для управления объемом работы, по­ставленной системой в очередь на выполнение, чтобы не допустить снижения производительности и перегрузки ваших сервисов.

С помощью буферизованного канала можно также реализовать такой прием, как *противодавление*. система работает в целом лучше, когда ее компоненты ограничивают объем выполняемой ими работы. Мы можем ограничить количество одновременных запросов в системе:
``` go
type PressureGauge struct{
	ch chan struct{}
}

func New(limit int) *PressureGauge{
	return &PressureGauge{
		ch: make(chan struct{}, limit)
	}
}

func (pg *PressureGauge) Process(f func()) error {
	select {
	case pg.ch <- struct{}{}:
		f()
		<-pg.ch
		return nil
	default:
		return errors.New("no more capacity")
	}
}
```

Если нужно объединить данные, получаемые из нескольких параллельных ис­точников, то с этой задачей прекрасно справляется оператор select. Однако при этом нужно предусмотреть правильную обработку закрытых каналов. Если какая-то из ветвей оператора select будет читать из закрытого канала, то эта операция всегда будет успешно выполняться, возвращая нулевое значение. При каждом выборе такой ветви должны осуществляться проверка корректности значения и выход из ветви. В противном случае периодическое выполнение таких опера­ций чтения может привести к большим затратам времени на чтение ненужных
значений. Даже если незакрытые каналы активно поставляют новые данные, программа все равно потратит какую-то часть времени на чтение из закрытого канала, поскольку select выбирает ветви случайным образом.
В такой ситуации может помочь то, что выглядит как ошибка, а именно чтение из канала nil (зануление канала, приведет к его игнорированию в select, ch = nil). 

В большинстве случаев интерактивные программы должны возвращать ответ в течение определенного промежутка времени:
``` go
func timeLimit[T any](worker func() T, limit time.Duration) (T, error) {
	out := make(chan T, 1)
	ctx, cancel := context.WithTimeout(context.Background(), limit)
	defer cancel()

	go func() {
		out <- worker()
	}()

	select {
	case result := <-out:
		return result, nil
	case <-ctx.Done():
		var zero T
		return zero, errors.New("work timed out") // ctx.Err()
	}
}
```

Когда нужно дождаться завершения нескольких горутин, следует использовать тип **WaitGroup** из пакета *sync* стандартной библиотеки. Переменную типа sync.WaitGroup не нужно инициализировать — достаточно объ­явить ее, поскольку мы используем нулевое значение. Мы не передаем переменную типа sync.WaitGroup явным образом. На это есть две причины. Первая причина состоит в том, что везде должен применяться один и тот же экземпляр sync.WaitGroup. Если передать пере­менную типа sync.WaitGroup в функцию горутины по значению, а не по ссылке, то функция получит копию и метод Done не сможет уменьшить счетчик в исходном
экземпляре sync.WaitGroup. Захватывая переменную типа sync.WaitGroup с по­мощью замыкания, мы гарантируем, что каждая горутина будет использовать один и тот же его экземпляр. Так же кон­курентность рекомендуется исключать из API - поэтому мы не передаём wg как аргумент, при этом замыкание управляет всем, что связано с конкурентностью, а основная функция реализует алгоритм.
``` go
func main() {
	var wg sync.WaitGroup
	wg.Add(3)
	go func() {
		defer wg.Done()
		doThing1()
	}()
	go func() {
		defer wg.Done()
		doThing2()
	}()
	go func() {
		defer wg.Done()
		doThing3()
	}()
	wg.Wait()
}
```

Когда несколько горутин пишут в один и тот же канал, необходимо проследить за тем, чтобы он закрывался только один раз:
``` go
func processAndGather[T, R any](in <-chan T, processor func(T) R, num int) []R {
	out := make(chan R, num)
	var wg sync.WaitGroup
	wg.Add(num)
	for i := 0; i < num; i++ {
		go func() {
			defer wg.Done()
			for v := range in {
				out <- processor(v)
			}
		}()
	}
	go func() {  // запускаем следящую горутину, которая дожидается завер­шения всех горутин-обработчиков и вызывает функцию close
		wg.Wait()
		close(out)
	}()
	var result []R
	for v := range out {  // выход из цикла for-range происходит, когда канал out закрывается и его буфер опустошается.
		result = append(result, v)
	}
	return result
}
```

В некоторых случаях требуется произвести так называемую отложенную загрузку, то есть один раз вызвать не­который код инициализации уже после запуска программы. Обычно этот прием используется, когда инициализация выполняется сравнительно медленно или требуется не при каждом запуске программы. Для этого можно использовать тип sync.Once. Не нужно настраивать экземпляр sync.Once - это наглядный пример полезности нулевого значения (те достаточно var once sync.Once). Мы должны проследить за тем, чтобы не создавались копии экземпляра sync.Once , поскольку у каждой копии есть соб­ственное состояние, указывающее, использовалась она уже или нет. Объявление экземпляра типа sync.Once внутри функции обычно является плохой идеей, по­скольку при каждом вызове функции будет создаваться новый экземпляр, ничего не знающий о предыдущих вызовах.

В Go 1.21 добавлены вспомогательные функции, упрощающие однократный вызов функции: sync.OnceFunc, sync.OnceValue и sync.OnceValues. Единствен­ное различие между ними — количество возвращаемых значений, получаемых от указанной функции (ноль, одно или два соответственно). Функции sync.OnceValue и sync.OnceValues — обобщенные и адаптируются к типу значений, возвращаемых исходной функцией. Им нужно передать исходную функцию, а они возвращают функцию, которая вызывает исходную только один раз. Значения, возвращаемые исходной функцией, кэшируются.

Структурируя код с помощью горутин, каналов и операторов select , мы отделяем друг от друга отдельные шаги, позволяем независимым частям программы выпол­няться в любом порядке и обеспечиваем четко выраженный обмен данными между зависимыми частями программы. Это также позволяет исключить вероятность зависания какой-либо части программы и обеспечить надлежащую обработку тайм-аутов, устанавливаемых и внутри текущей функции, и внутри предыдущих функций в стеке вызовов. 

**Мьютекс** накладывает ограничение на конкурентное выполнение определенного кода или на доступ к совместно используемым данным. Эта защищаемая часть программы называется *критической секцией*. Главная проблема мьютексов — они затрудняют понимание движения данных внутри программы. Когда значение передается из одной горутины в дру­гую посредством ряда каналов, вполне очевидно, как движутся данные. Доступ
к значению всегда выполняется только в одной горутине.

Делитесь памятью путем общения, а не общайтесь, делясь памятью (используйте каналы и не используйте мютексы от mutual exclusion). 

Типичный пример такой ситуации (когда стоит использовать мьютекс) — когда горутины читают или записывают совместно используемое значение, но не обрабатывают его.

Стандартная библиотека предлагает две реализации мьютекса, обе они включены в пакет sync. Первая — тип **Mutex**, который имеет методы Lock и Unlock. Вызов метода Lock приостанавливает выполнение текущей горутины, если критическая секция в данный момент занята другой горутиной. Если критическая секция сво­бодна, текущая горутина устанавливает блокировку и выполняет код в критиче­ской секции. Вызов метода Unlock завершает использование критической секции. Вторая реализация мьютекса — тип **RWMutex**, который позволяет устанавливать блокировки на чтение или на запись. Установить блокировку на запись и выпол­нить критическую секцию может только одна пишущая горутина, но установить блокировку на чтение могут сразу несколько читающих горутин, что обеспечивает возможность одновременного доступа к критической секции для чтения. Управ­ление блокировкой на запись осуществляется с помощью методов Lock и Unlock, а блокировкой на чтение — с помощью методов RLock и RUnlock. Всякий раз, устанавливая блокировку, нужно позаботиться о том, чтобы она высвобождалась. Используйте оператор defer для вызова метода Unlock непо­средственно после вызова метода Lock или RLock.

Упростить выбор между каналами и мьютексами вам поможет схема:
- Если нужно координировать горутины или отслеживать значение по мере его преобразования с помощью нескольких горутин, используйте каналы.
- Если нужно обеспечить совместный доступ к полю структуры, применяйте мьютексы.
- Если вы выявили критическую проблему производительности при использо­вании каналов и не можете найти других спосо­бов ее решения, задействуйте вместо каналов мьютексы.

Еще одна проблема заключается в том, что мьютексы в Go не являются повторно входимыми. Если горутина по­пытается установить одну и ту же блокировку дважды, это приведет к зависанию,
потому что она приостановится в ожидании высвобождения ранее установленной ею блокировки.

sync.Map - это версия встроенного типа map с поддержкой конкурентности, но её уместно использовать в следущий случаях:
- если нужно обеспечить совместное использование отображения, когда пары «ключ/значение» добавляются в отображение один раз и читаются многократно.
- когда несколько горутин совместно используют отображение, но не об­ращаются к ключам и значениям друг друга.

Ещё одна проблема потенциальная **sync.Map** задействует тип any в качестве типа ключей и значе­ний, что не позволяет компилятору проследить за тем, чтобы использовались надлежащие типы данных.  

Как и типы sync.WaitGroup и sync.Once, мьютексы никогда не следует копиро­вать. Если мьютекс передается в функцию или применяется как поле структуры, это следует делать посредством указателя. Если мьютекс будет скопирован, вы не сможете обеспечить совместное использование его блокировки.

Наряду с мьютексами Go предлагает альтернативный способ согласованного использования данных несколькими потоками. Пакет **sync/atomic** позволяет применять встроенные в современные процессоры наборы атомарных операций с переменными — сложение, обмен, загрузку, сохранение и сравнение с обменом для значений, которые могут поместиться в одном регистре.
