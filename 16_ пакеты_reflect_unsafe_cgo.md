Иногда для решения задачи недостаточно стандартного Go-кода. Например, если тип данных невозможно определить на этапе компиляции, вы можете обеспечить взаимодействие с дан­ными и даже их конструирование с помощью средств поддержки рефлексии из пакета reflect . Если нужно воспользоваться преимуществами, которые дает вам схема размещения в памяти типов языка Go, можете задействовать пакет unsafe. А если некоторая функциональность может быть обеспечена только с помощью библиотек, написанных на языке C, можно вызывать C-код с по­мощью пакета cgo.

Рефлексия позволяет работать с типами на этапе выполнения. Те она позволяет исследовать типы на этапе выполнения, а также изучать, модифицировать и создавать переменные, функции и структуры на этапе выполнения.
Области применения рефлексии можно разделить на следующие основные категории:
- Чтение из базы данных и запись в нее. Пакет database/sql использует ре­флексию для того, чтобы отправлять записи в базы данных и, наоборот, читать записи из баз данных.
- Встроенные библиотеки шаблонизации языка Go text/template и html/template используют рефлексию для обработки значений, передаваемых шаблонам.
- Пакет fmt активно задействует рефлексию для определения типа предостав­ляемых параметров при вызове функции fmt.Println и других подобных функций.
- Пакет errors использует рефлексию для реализации функций errors.Is и errors.As.
- Пакет sort применяет рефлексию для реализации функций сортировки и проверки содержимого срезов любого типа: sort.Slice, sort.SliceStable и sort.SliceIsSorted.
- Последняя основная область применения рефлексии в стандартной библио­теке — преобразование данных в форматы JSON, XML и другие, поддержи­ваемые различными пакетами encoding, и обратно. Рефлексия используется
для доступа к тегам структур, а также для чтения и записи соответствующих полей структур.

Общей особенностью этих примеров является применение рефлексии для чтения или форматирования данных, которые импортируются в Go-программу или экс­портируются из нее. Рефлексия часто используется на границе между программой и внешним миром. У рефлексии есть своя цена -  она значительно замедляет выпол­нение операций. Еще одной областью применения пакета reflect из стандартной библиотеки Go является тестирование, па­
кет reflect содержит функцию DeepEqual. Она реализована в пакете reflect по той причине, что для выполнения своей работы использует рефлексию. Функция reflect.DeepEqual сравнивает два значения более тщательно, чем
оператор ==, и такой способ сравнения задействуется в стандартной библио­теке для проверки результатов тестирования, а также сравнения чего-то, что нельзя сравнить с помощью оператора ==, например срезов и отображений. В большинстве случаев можно обойтись без DeepEqual, потому что в Go 1.21 для сравнения срезов и отображений были добавлены более быстрые методы slices.Equal и maps.Equal.

Типы и функции, реализующие рефлексию в Go, опре­делены в пакете **reflect** стандартной библиотеки. Механизм действия рефлексии опирается на следующие три концепции: типы, разновидности типов и значения.
В контексте рефлексии тип является именно тем, что означает это слово. То есть он определяет, какими свойствами обладает переменная, какие значения она может содержать и как с ней можно взаимодействовать. При использовании рефлексии вы можете запросить у типа информацию об этих свойствах с по­мощью кода.
Получить рефлексивное представление типа переменной можно с помощью функции TypeOf из пакета reflect:
``` go
vType := reflect.TypeOf(v)
```
Функция reflect.TypeOf возвращает значение типа reflect.Type, представля­ющее тип переданной в эту функцию переменной. Тип reflect.Type обладает рядом методов, возвращающих информацию о типе переменной.
Вот некоторые методы:
``` go
var x int
xt := reflect.TypeOf(x)
fmt.Println(xt.Name()) // возвращает int

f := Foo{}
ft := reflect.TypeOf(f)
fmt.Println(ft.Name()) // возвращает Foo

xpt := reflect.TypeOf(&x)
fmt.Println(xpt.Name()) // возвращает пустую строку
```
Здесь мы объявляем переменную x типа int . Передаем ее в функцию reflect.TypeOf и получаем обратно экземпляр типа reflect.Type. Для простых типов, таких как int, метод Name() возвращает имя типа — в данном случае строку int для типа int. Для структур этот метод возвращает имя структуры. Некоторые типы, например срезы и указатели, не имеют имени типа, в таком случае метод Name возвращает пустую строку.
Метод Kind типа reflect.Type возвращает значение типа reflect.Kind — констан­ту, которая указывает, на основе чего создан тип: среза, отображения, указателя, структуры, интерфейса, строки, массива, функции, типа int или какого-то дру­гого простого типа. 

В чем разница между типом и разновидностью типа? Запомните следующее правило: если вы определяете струк­туру с именем Foo, то она обладает разновидностью reflect.Struct и типом Foo.

 При использовании рефлексии следует помнить о том, что любой код из пакета reflect исходит из предположе­ния, что вы знаете, что делаете. Некоторые из методов типа reflect.Type и других
типов пакета reflect имеют смысл только для определенных разновидностей типов. Так, например, у типа reflect.Type есть метод NumIn. Если экземпляр типа reflect.Type представляет функцию, то NumIn вернет количество ее входных параметров. Если экземпляр типа reflect.Type представляет что-то другое, то вызов метода NumIn сгенерирует панику.

Еще одним важным методом типа reflect.Type является метод Elem. Некоторые типы в Go содержат ссылки на другие типы, и метод Elem позволяет выяснить, что представляют собой эти вложенные типы. Например, вызовем функцию reflect.TypeOf, передав ей указатель на тип int:
``` go
var x int
xpt := reflect.TypeOf(&x)
fmt.Println(xpt.Name()) // возвращает пустую строку
fmt.Println(xpt.Kind()) // возвращает reflect.Ptr
fmt.Println(xpt.Elem().Name()) // возвращает int
fmt.Println(xpt.Elem().Kind()) // возвращает reflect.Int
```
В результате мы получим экземпляр типа reflect.Type с пустой строкой вме­сто имени и разновидностью reflect.Ptr, что подразумевает указатель. Когда экземпляр типа reflect.Type представляет указатель, метод Elem возвращает экземпляр типа reflect.Type, представляющий тот тип, на который указывает этот указатель. В данном случае метод Name возвращает строку int, а метод Kind — разновидность reflect.Int. Метод Elem можно использовать также для срезов, отображений, каналов и массивов.

У типа reflect.Type тоже есть методы для анализа структур. Метод NumField позволяет узнать, сколько полей содержит структура, а метод Field — извлечь поле структуры по индексу. Второй метод возвращает структуру каждого поля, как ее определяет тип reflect.StructField, что включает в себя имя, порядок, тип и имеющиеся в поле теги структур:
``` go
type Foo struct {
  A int `myTag:"value"`
  B string `myTag:"value2"`
}

var f Foo
ft := reflect.TypeOf(f)
for i := 0; i < ft.NumField(); i++ {
  curField := ft.Field(i)
  fmt.Println(curField.Name, curField.Type.Name(), curField.Tag.Get("myTag"))
}

// output:
// A int value
// B string value2
```
Мы создаем экземпляр типа Foo и с помощью функции reflect.TypeOf получаем экземпляр типа reflect.Type, представляющий переменную f. Затем с по­мощью метода NumField настраиваем цикл for так, чтобы он обошел индексы всех полей в переменной f. Далее с помощью метода Field получаем структуру reflect.StructField, представляющую отдельное поле. После этого мы можем использовать поля структуры reflect.StructField для получения дополнитель­ ной информации о поле.

Рефлексию можно использовать не только для выяснения типов, но и для чте­ния значений переменных, присваивания им значений и создания с нуля новых значений. С помощью функции reflect.ValueOf можно создать экземпляр типа reflect.Value, представляющий значение переменной:
``` go
vValue := reflect.ValueOf(v)
```
Поскольку каждая переменная в Go обладает типом, reflect.Value имеет метод Type, который возвращает экземпляр типа reflect.Type для экземпляра типа reflect.Value. Как и у типа reflect.Type, у типа reflect.Value есть метод Kind. Подобно тому как у типа reflect.Type есть методы для получения информации о типе переменной, у типа reflect.Value есть методы для получения информации о значении переменной.
Для начала посмотрим, как читать значения из экземпляров типа reflect.Value. Метод Interface возвращает значение переменной как интерфейс any. При этом теряется информация о типе, поэтому при записи возвращаемого значения в пере­менную его нужно снова привести к правильному типу с помощью операции утверждения типа:
``` go
s := []string{"a", "b", "c"}
sv := reflect.ValueOf(s) // переменная sv имеет тип reflect.Value
s2 := sv.Interface().([]string) // переменная s2 имеет тип []string
```
Метод Interface можно вызывать для экземпляров типа reflect.Value, содержа­щих значения любого типа, однако имеются и специализированные методы для случаев, когда переменная относится к одному из встроенных простых типов: Bool, Complex, Int, Uint, Float и String. Есть также метод Bytes для случая, когда переменная представляет собой байтовый срез. Вызов метода, который не со­ответствует типу значения, содержащегося в экземпляре типа reflect.Value, сгенерирует панику.

Рефлексию можно использовать также для присвоения значения переменной, однако эта операция выполняется в три этапа. Сначала нужно передать указа­тель на переменную в функцию reflect.ValueOf, которая вернет экземпляр типа reflect.Value, представляющий этот указатель:
``` go
i := 10
iv := reflect.ValueOf(&i)
```
Затем необходимо добраться непосредственно до значения, которое нужно поме­нять. Вызвав метод Elem в экземпляре типа reflect.Value, мы можем получить то значение, на которое указывает указатель, переданный в функцию reflect.ValueOf . Подобно тому как метод Elem типа reflect.Type возвращает тип, на который указы­вает вмещающий тип, метод Elem типа reflect.Value возвращает значение, на ко­торое указывает указатель, или значение, содержащееся в экземпляре интерфейса:
``` go
ivv := iv.Elem()
```
Теперь осталось непосредственно применить метод, используемый для установки значения. Наряду со специализированными методами для чтения простых типов в пакете reflect имеются и специализированные методы для установки значений простых типов: SetBool , SetInt, SetFloat, SetString и SetUint. В своем примере мы можем изменить значение переменной i, выполнив вызов ivv.SetInt(20).
Если выведем значение переменной i, то увидим, что теперь оно равно 20:
``` go
ivv.SetInt(20)
fmt.Println(i) // выводит 20
```
В случае всех остальных типов следует использовать метод Set, который прини­мает переменную типа reflect.Value. При этом присваиваемое значение может не быть указателем, потому что мы просто читаем это значение, не изменяя его. И подобно тому, как метод Interface(), помимо прочего, может применяться для чтения простых типов, метод Set может использоваться для записи простых типов.

Необходимость передачи указателя в функцию reflect.ValueOf для изменения значения входного параметра объясняется тем, что эта функция ведет себя так же, как любая другая функция в языке Go. Использование параметров указательного типа означает, что функция должна модифицировать значение параметра. Модификация производится путем разыменования указателя и при­ сваивания значения. Например, следующие две функции производят одно и то же действие:
``` go
func changeInt(i *int) {
 *i = 20
}
func changeIntReflect(i *int) {
 iv := reflect.ValueOf(i)
 iv.Elem().SetInt(20)
}
```
Попытка присвоить экземпляру reflect.Value значение неправильного типа приведет к панике.

Для создания переменной  служит функция reflect.New — рефлексивный аналог функции new. Она принимает экземпляр типа reflect.Type и возвращает экземпляр типа reflect.Value, представляющий
указатель на экземпляр типа reflect.Value, соответствующий указанному типу. Поскольку это указатель, можно модифицировать его, а затем присвоить моди­фицированное значение переменной с помощью метода Interface.
Подобно тому как метод reflect.New можно задействовать для создания указателя на скалярный тип, с помощью рефлексии можно создавать те же объекты, которые создает ключевое слово make, используя следующие функции:
``` go
func MakeChan(typ Type, buffer int) Value
func MakeMap(typ Type) Value
func MakeMapWithSize(typ Type, n int) Value
func MakeSlice(typ Type, len, cap int) Value
```
Эти функции принимают экземпляр типа reflect.Type, который вместо вложен­ного типа представляет составной тип.
Конструирование экземпляра типа reflect.Type всегда следует начинать со значе­ния. Однако если у вас нет значения, то для создания переменной, представляющей экземпляр типа reflect.Type, можно использовать следующий хитрый прием:
``` go
var stringType = reflect.TypeOf((*string)(nil)).Elem()
var stringSliceType = reflect.TypeOf([]string(nil))
```
Переменная stringType содержит экземпляр типа reflect.Type, представляющий тип string, а переменная stringSliceType — экземпляр типа reflect.Type, пред­ставляющий тип []string. 
В первой строке мы преобразуем здесь значение nil в указатель на тип string и за­действуем функцию reflect.TypeOf для создания экземпляра типа reflect.Type, представляющего этот указательный тип, после чего вызываем метод Elem этого экземпляра, чтобы получить базовый тип. В силу используемого в Go порядка выполнения операций мы заключили *string в скобки, чтобы компилятор не по­считал, что мы хотим преобразовать значение nil в значение типа string — эта операция недопустима.
В случае с переменной stringSliceType дело обстоит чуть проще, потому что срез может иметь значение nil. Нам остается лишь привести значение nil к типу []string и передать его в функцию reflect.TypeOf.
Теперь, располагая этими типами, можно вызвать методы reflect.New и re­flect.MakeSlice, как показано далее:
``` go
ssv := reflect.MakeSlice(stringSliceType, 0, 10)
sv := reflect.New(stringType).Elem()
sv.SetString("hello")
ssv = reflect.Append(ssv, sv)
ss := ssv.Interface().([]string)
fmt.Println(ss) // выводит [hello]
```

Используйте рефлексию для проверки значения интерфейса на равенство nil.

Если вам нужно проверить, равно ли значению nil ассоциированное с интерфейсом значение, то это можно сделать с помощью рефлексии и методов IsValid и IsNil:
``` go
func hasNoValue(i interface{}) bool {
 iv := reflect.ValueOf(i)
 if !iv.IsValid() {
  return true
 }

 switch iv.Kind() {
  case reflect.Pointer, reflect.Slice, reflect.Map, reflect.Func,reflect.Interface:
   return iv.IsNil()
  default:
   return false
 }
}
```
Метод IsValid возвращает true , если экземпляр типа reflect.Value содержит любое другое значение, кроме интерфейса, равного nil. Это нужно проверять в первую очередь, потому что, когда метод IsValid возвращает false, вызов любого другого метода типа reflect.Value, что неудивительно, генерирует панику. Метод IsNil возвращает true, если экземпляр типа reflect.Value содержит значение nil, но его можно использовать лишь в том случае, когда разновидность типа (reflect.Kind) допускает равенство значению nil. Если вызвать этот метод для типа, нулевое значение которого отличается от nil, то это, как вы уже догадались, приведет к панике.

Используйте рефлексию для создания маршалера данных.

Создавайте с помощью рефлексии функции для автоматизации повторяющихся задач. Например, вот как может выглядеть фабричная функция, снабжающая любую переданную ей функцию информацией о времени выполнения:
``` go
func MakeTimedFunction(f any) any {
 ft := reflect.TypeOf(f)
 fv := reflect.ValueOf(f)
 wrapperF := reflect.MakeFunc(ft, func(in []reflect.Value) []reflect.Value {
 start := time.Now()
 out := fv.Call(in)
 end := time.Now()
 fmt.Println(end.Sub(start))
  return out
 })
 return wrapperF.Interface()
}
```
Поскольку эта функция должна принимать на входе любую функцию, ее параметр объявлен с типом any. Она передает экземпляр типа reflect.Type, представля­ ющий полученную функцию, в вызов reflect.MakeFunc вместе с замыканием, которое фиксирует начальный момент времени, вызывает исходную функцию с помощью рефлексии, фиксирует конечный момент времени, выводит разницу между началом и концом и возвращает значение, вычисленное исходной функ­цией. Поскольку reflect.MakeFunc возвращает экземпляр типа reflect.Value, мы вызываем метод Interface этого типа, чтобы получить возвращаемое значение. Использовать эту функцию можно следующим образом:
``` go
func timeMe(a int) int {
 time.Sleep(time.Duration(a) * time.Second)
 result := a * 2
 return result
}

func main() {
 timed:= MakeTimedFunction(timeMe).(func(int) int)
 fmt.Println(timed(2))
}
```

Рефлексию можно использовать для создания структур, но лучше этого не делать.  Функ­ция reflect.StructOf принимает срез полей типа reflect.StructField и воз­вращает экземпляр типа reflect.Type, представляющий новую структуру. Такие структуры можно присваивать только переменным типа any, а их поля можно читать и изменять только с использованием рефлексии. Эта функция представляет интерес фактически только с научной точки зрения.

Рефлексия не позволяет создавать методы. Те при помощи *рефлексии* можно создавать структуры, но нельзя снабдить их дополнительными методами. Это означает, что вы не сможете с помощью рефлексии создать новый тип, реализующий некоторый интерфейс.

Как было сказано раньше - рефлексия может играть важную роль при преобразовании данных на внешней границе Go-кода.
