Иногда для решения задачи недостаточно стандартного Go-кода. Например, если тип данных невозможно определить на этапе компиляции, вы можете обеспечить взаимодействие с дан­ными и даже их конструирование с помощью средств поддержки рефлексии из пакета reflect . Если нужно воспользоваться преимуществами, которые дает вам схема размещения в памяти типов языка Go, можете задействовать пакет unsafe. А если некоторая функциональность может быть обеспечена только с помощью библиотек, написанных на языке C, можно вызывать C-код с по­мощью пакета cgo.

Рефлексия позволяет работать с типами на этапе выполнения. Те она позволяет исследовать типы на этапе выполнения, а также изучать, модифицировать и создавать переменные, функции и структуры на этапе выполнения.
Области применения рефлексии можно разделить на следующие основные категории:
- Чтение из базы данных и запись в нее. Пакет database/sql использует ре­флексию для того, чтобы отправлять записи в базы данных и, наоборот, читать записи из баз данных.
- Встроенные библиотеки шаблонизации языка Go text/template и html/template используют рефлексию для обработки значений, передаваемых шаблонам.
- Пакет fmt активно задействует рефлексию для определения типа предостав­ляемых параметров при вызове функции fmt.Println и других подобных функций.
- Пакет errors использует рефлексию для реализации функций errors.Is и errors.As.
- Пакет sort применяет рефлексию для реализации функций сортировки и проверки содержимого срезов любого типа: sort.Slice, sort.SliceStable и sort.SliceIsSorted.
- Последняя основная область применения рефлексии в стандартной библио­теке — преобразование данных в форматы JSON, XML и другие, поддержи­ваемые различными пакетами encoding, и обратно. Рефлексия используется
для доступа к тегам структур, а также для чтения и записи соответствующих полей структур.

Общей особенностью этих примеров является применение рефлексии для чтения или форматирования данных, которые импортируются в Go-программу или экс­портируются из нее. Рефлексия часто используется на границе между программой и внешним миром. У рефлексии есть своя цена -  она значительно замедляет выпол­нение операций. Еще одной областью применения пакета reflect из стандартной библиотеки Go является тестирование, па­
кет reflect содержит функцию DeepEqual. Она реализована в пакете reflect по той причине, что для выполнения своей работы использует рефлексию. Функция reflect.DeepEqual сравнивает два значения более тщательно, чем
оператор ==, и такой способ сравнения задействуется в стандартной библио­теке для проверки результатов тестирования, а также сравнения чего-то, что нельзя сравнить с помощью оператора ==, например срезов и отображений. В большинстве случаев можно обойтись без DeepEqual, потому что в Go 1.21 для сравнения срезов и отображений были добавлены более быстрые методы slices.Equal и maps.Equal.

Типы и функции, реализующие рефлексию в Go, опре­делены в пакете **reflect** стандартной библиотеки. Механизм действия рефлексии опирается на следующие три концепции: типы, разновидности типов и значения.
В контексте рефлексии тип является именно тем, что означает это слово. То есть он определяет, какими свойствами обладает переменная, какие значения она может содержать и как с ней можно взаимодействовать. При использовании рефлексии вы можете запросить у типа информацию об этих свойствах с по­мощью кода.
Получить рефлексивное представление типа переменной можно с помощью функции TypeOf из пакета reflect:
``` go
vType := reflect.TypeOf(v)
```
Функция reflect.TypeOf возвращает значение типа reflect.Type, представля­ющее тип переданной в эту функцию переменной. Тип reflect.Type обладает рядом методов, возвращающих информацию о типе переменной.
Вот некоторые методы:
``` go
var x int
xt := reflect.TypeOf(x)
fmt.Println(xt.Name()) // возвращает int

f := Foo{}
ft := reflect.TypeOf(f)
fmt.Println(ft.Name()) // возвращает Foo

xpt := reflect.TypeOf(&x)
fmt.Println(xpt.Name()) // возвращает пустую строку
```
Здесь мы объявляем переменную x типа int . Передаем ее в функцию reflect.TypeOf и получаем обратно экземпляр типа reflect.Type. Для простых типов, таких как int, метод Name() возвращает имя типа — в данном случае строку int для типа int. Для структур этот метод возвращает имя структуры. Некоторые типы, например срезы и указатели, не имеют имени типа, в таком случае метод Name возвращает пустую строку.
Метод Kind типа reflect.Type возвращает значение типа reflect.Kind — констан­ту, которая указывает, на основе чего создан тип: среза, отображения, указателя, структуры, интерфейса, строки, массива, функции, типа int или какого-то дру­гого простого типа. 

В чем разница между типом и разновидностью типа? Запомните следующее правило: если вы определяете струк­туру с именем Foo, то она обладает разновидностью reflect.Struct и типом Foo.

 При использовании рефлексии следует помнить о том, что любой код из пакета reflect исходит из предположе­ния, что вы знаете, что делаете. Некоторые из методов типа reflect.Type и других
типов пакета reflect имеют смысл только для определенных разновидностей типов. Так, например, у типа reflect.Type есть метод NumIn. Если экземпляр типа reflect.Type представляет функцию, то NumIn вернет количество ее входных параметров. Если экземпляр типа reflect.Type представляет что-то другое, то вызов метода NumIn сгенерирует панику.

Еще одним важным методом типа reflect.Type является метод Elem. Некоторые типы в Go содержат ссылки на другие типы, и метод Elem позволяет выяснить, что представляют собой эти вложенные типы. Например, вызовем функцию reflect.TypeOf, передав ей указатель на тип int:
``` go
var x int
xpt := reflect.TypeOf(&x)
fmt.Println(xpt.Name()) // возвращает пустую строку
fmt.Println(xpt.Kind()) // возвращает reflect.Ptr
fmt.Println(xpt.Elem().Name()) // возвращает int
fmt.Println(xpt.Elem().Kind()) // возвращает reflect.Int
```
В результате мы получим экземпляр типа reflect.Type с пустой строкой вме­сто имени и разновидностью reflect.Ptr, что подразумевает указатель. Когда экземпляр типа reflect.Type представляет указатель, метод Elem возвращает экземпляр типа reflect.Type, представляющий тот тип, на который указывает этот указатель. В данном случае метод Name возвращает строку int, а метод Kind — разновидность reflect.Int. Метод Elem можно использовать также для срезов, отображений, каналов и массивов.

У типа reflect.Type тоже есть методы для анализа структур. Метод NumField позволяет узнать, сколько полей содержит структура, а метод Field — извлечь поле структуры по индексу. Второй метод возвращает структуру каждого поля, как ее определяет тип reflect.StructField, что включает в себя имя, порядок, тип и имеющиеся в поле теги структур:
``` go
type Foo struct {
  A int `myTag:"value"`
  B string `myTag:"value2"`
}

var f Foo
ft := reflect.TypeOf(f)
for i := 0; i < ft.NumField(); i++ {
  curField := ft.Field(i)
  fmt.Println(curField.Name, curField.Type.Name(), curField.Tag.Get("myTag"))
}

// output:
// A int value
// B string value2
```
Мы создаем экземпляр типа Foo и с помощью функции reflect.TypeOf получаем экземпляр типа reflect.Type, представляющий переменную f. Затем с по­мощью метода NumField настраиваем цикл for так, чтобы он обошел индексы всех полей в переменной f. Далее с помощью метода Field получаем структуру reflect.StructField, представляющую отдельное поле. После этого мы можем использовать поля структуры reflect.StructField для получения дополнитель­ ной информации о поле.

Рефлексию можно использовать не только для выяснения типов, но и для чте­ния значений переменных, присваивания им значений и создания с нуля новых значений. С помощью функции reflect.ValueOf можно создать экземпляр типа reflect.Value, представляющий значение переменной:
``` go
vValue := reflect.ValueOf(v)
```
Поскольку каждая переменная в Go обладает типом, reflect.Value имеет метод Type, который возвращает экземпляр типа reflect.Type для экземпляра типа reflect.Value. Как и у типа reflect.Type, у типа reflect.Value есть метод Kind. Подобно тому как у типа reflect.Type есть методы для получения информации о типе переменной, у типа reflect.Value есть методы для получения информации о значении переменной.
Для начала посмотрим, как читать значения из экземпляров типа reflect.Value. Метод Interface возвращает значение переменной как интерфейс any. При этом теряется информация о типе, поэтому при записи возвращаемого значения в пере­менную его нужно снова привести к правильному типу с помощью операции утверждения типа:
``` go
s := []string{"a", "b", "c"}
sv := reflect.ValueOf(s) // переменная sv имеет тип reflect.Value
s2 := sv.Interface().([]string) // переменная s2 имеет тип []string
```
Метод Interface можно вызывать для экземпляров типа reflect.Value, содержа­щих значения любого типа, однако имеются и специализированные методы для случаев, когда переменная относится к одному из встроенных простых типов: Bool, Complex, Int, Uint, Float и String. Есть также метод Bytes для случая, когда переменная представляет собой байтовый срез. Вызов метода, который не со­ответствует типу значения, содержащегося в экземпляре типа reflect.Value, сгенерирует панику.

Рефлексию можно использовать также для присвоения значения переменной, однако эта операция выполняется в три этапа. Сначала нужно передать указа­тель на переменную в функцию reflect.ValueOf, которая вернет экземпляр типа reflect.Value, представляющий этот указатель:
``` go
i := 10
iv := reflect.ValueOf(&i)
```
Затем необходимо добраться непосредственно до значения, которое нужно поме­нять. Вызвав метод Elem в экземпляре типа reflect.Value, мы можем получить то значение, на которое указывает указатель, переданный в функцию reflect.ValueOf . Подобно тому как метод Elem типа reflect.Type возвращает тип, на который указы­вает вмещающий тип, метод Elem типа reflect.Value возвращает значение, на ко­торое указывает указатель, или значение, содержащееся в экземпляре интерфейса:
``` go
ivv := iv.Elem()
```
Теперь осталось непосредственно применить метод, используемый для установки значения. Наряду со специализированными методами для чтения простых типов в пакете reflect имеются и специализированные методы для установки значений простых типов: SetBool , SetInt, SetFloat, SetString и SetUint. В своем примере мы можем изменить значение переменной i, выполнив вызов ivv.SetInt(20).
Если выведем значение переменной i, то увидим, что теперь оно равно 20:
``` go
ivv.SetInt(20)
fmt.Println(i) // выводит 20
```
В случае всех остальных типов следует использовать метод Set, который прини­мает переменную типа reflect.Value. При этом присваиваемое значение может не быть указателем, потому что мы просто читаем это значение, не изменяя его. И подобно тому, как метод Interface(), помимо прочего, может применяться для чтения простых типов, метод Set может использоваться для записи простых типов.

Необходимость передачи указателя в функцию reflect.ValueOf для изменения значения входного параметра объясняется тем, что эта функция ведет себя так же, как любая другая функция в языке Go. Использование параметров указательного типа означает, что функция должна модифицировать значение параметра. Модификация производится путем разыменования указателя и при­ сваивания значения. Например, следующие две функции производят одно и то же действие:
``` go
func changeInt(i *int) {
 *i = 20
}
func changeIntReflect(i *int) {
 iv := reflect.ValueOf(i)
 iv.Elem().SetInt(20)
}
```
Попытка присвоить экземпляру reflect.Value значение неправильного типа приведет к панике.
