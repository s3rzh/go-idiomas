Go — *статически типизированный язык*, позволяющий использовать как встроенные, так и пользовательские типы. Go позволяет привязывать к типам методы.

Объявление пользовательского типа:
``` go
type Person struct {
	FirstName string
	LastName string
	Age int
}
```
структурные типы
``` go
type Score int
type Converter func(string)Score
type TeamScores map[string]Score
```
для определения конкретного типа можно использовать любой простой тип или литерал составного типа. 

Абстрактный тип указывает, что должен делать тип, но не указывает, как это должно быть сделано.

Конкретный тип указывает, что и как должен делать тип. Это значит, что он обладает определенным методом сохранения своих данных и предоставляет реализацию для всех объявленных в нем методов. 

Go параметры указательного типа используются для обозначения, что приемник-указатель может быть изменен методом. 
Если метод вносит изменения в приемник, необходимо использовать приемник указателей.
Если метод должен учитывать вероятность того, что экземпляр будет равен nil, необходимо использовать приемник указателей.

Если метод не вносит изменения в приёмник, можно использовать приёмник *значений*.	

Если хотя бы один из определяемых для типа методов использует приёмник указателей, для единообразия рекомендуется использовать приемник указателей во всех методах, включая те из них, которые не меняют приёмник.

``` go
type Counter struct {
  total int
  lastUpdated time.Time
}
func (c *Counter) Increment() {
  c.total++
  c.lastUpdated = time.Now()
}
func (c Counter) String() string {
  return fmt.Sprintf("total: %d, last updated: %v", c.total, c.lastUpdated)
}
```
При использовании приемника указателей для локальной переменной значимого типа Go автоматически преобразует эту переменную в указательный тип. То есть в данном случае c.Increment() преобразуется в (&c).Increment().

Go включает в набор методов экземпляра указательного типа и те методы, которые используют приемник указателей, и те методы, которые используют приемник значений. В случае экземпляра значимого типа
в набор методов включаются только методы с приемником значений.

Если для экземпляра, равного nil, вызвать метод, использующий приёмник значений, вы получите панику из-за отсутствия значения в том месте, куда указывает указатель.

Метод с приемником значений не может выполнять проверку на равенство значению nil и, как уже говорилось, выдает панику в случае его вызова для приемника, равного nil.

язык Go позволяет вызывать методы для приемника, равного nil, и иногда эта возможность может быть очень полезной, как в нашем примере с узлами дерева (но чаще это бесполезно).
Приемник указателей действует точно так же, как параметр функций указательного типа: это копия указателя, которая передается
в метод. Как и в случае передачи функции параметра, равного nil, изменение этой копии указателя не приведет к изменению оригинала. Это означает, что вы не можете написать метод с приемником указателей, который бы принимал указатель, равный nil, и делал исходный указатель не равным nil. Если ваш метод использует приемник указателей и не работает, когда приемник равен nil, выполняйте проверку на равенство значению nil и возвращайте ошибку.

``` go
type HighScore Score
type Employee Person
```
Помимо объявления типа на основе одного из встроенных типов языка Go или литерала структуры, вы также можете объявлять пользовательский тип на основе другого пользовательского типа

Хотя объявление типа на основе другого типа выглядит как наследование, оно им не является. Сходство здесь состоит лишь в том, что два типа обладают одним и тем же базовым типом. Между этими типами нет никакой иерархии.
Вы не можете присвоить экземпляр типа HighScore переменной типа Score и наоборот без преобразования типа, равно как не можете присвоить эти экземпляры переменной типа int без преобразования
типа. Кроме того, методы, определенные для типа Score, не определены для типа HighScore:
``` go
// вы можете присвоить значения нетипизированным константам
var i int = 300
var s Score = 100
var hs HighScore = 200
hs = s // ошибка компиляции!
s = i // ошибка компиляции!
s = Score(i) // ok
hs = HighScore(s) // ok
```

Преобразование типа в тип с таким же базовым типом оставляет неизменным его место размещения в памяти, но при этом связывает с ним другие методы.

Типы являются документацией. Они делают код более понятным, предоставляя имена для концепций и описывая, какие данные должны использоваться в том или ином месте. Если методу будет
передаваться параметр типа Percentage, а не типа int, ваш код будет более понятным для других программистов и вероятность того, что они передадут этому
методу некорректное значение, будет гораздо ниже.

Та же логика справедлива и в случае объявления пользовательского типа на основе другого пользовательского типа. Если над одинаковыми базо­выми ­данными требуется выполнять разные наборы операций, создайте два
типа. При этом объявление одного типа на основе другого позволяет в определенной мере избежать повторения и ясно показывает, что эти два типа взаимосвязаны.

**Йота** (иногда) используется для создания перечислений  с помощью которой вы можете присвоить ряд инкрементно возрастающих значений набору констант.
При использовании iota рекомендуется сначала на основе типа int определить тип, который будет служить для представления всех допустимых значений
``` go
type MailCategory int
```

Затем нужно определить набор значений для этого типа с помощью блока const
``` go
const (
  Uncategorized MailCategory = iota
  Personal
  Spam
  Social
  Advertisements
)
```
Это означает, что он присваивает 0 первой константе (Uncategorized), 1 — второй константе (Personal) и т.д.

Если мы решим использовать еще один блок const, значение iota будет снова сброшено в 0.

Использовать перечисления на основе iota имеет смысл лишь в том случае, когда нужно просто отличать друг от друга некоторый ряд значений, и неважно, чему именно они будут равны.
Если ­фактическое значение константы играет важную роль, его следует указать явным образом.


Константам можно присваивать литеральные выражения.

``` go
type BitField int
const (
	Field1 BitField = 1 << iota            // присваивается 1  // смещение на 0 влево
	Field2 // присваивается 2              // смещение на 1 влево  итд
	Field3 // присваивается 4
	Field4 // присваивается 8
)
```
Нумерация iota начинается с нуля. Если для константы невозможно выбрать имеющее смысл значение по умолчанию, обычно рекомендуется в качестве первого значения йоты в блоке констант задать идентификатор _ или константу, показывающую, что значение является некорректным. Это позволяет легко выявлять те случаи, когда не удается произвести инициализацию переменной должным образом.

Язык Go не позволяет использовать наследование, но поощряет повторное использование кода, предоставляя встроенную поддержку для композиции и повышения типа.

``` go
type Employee struct {
	Name string
	ID string
}

type Manager struct {
	Employee
	Reports []Employee
}
```
Обратите внимание, что структура Manager содержит поле типа Employee, но этому полю не присваивается какое-либо имя. Это делает поле Employee встроенным полем. Любые поля или методы, объявленные во встроенном поле, повышаются до содержащей его структуры и могут быть вызваны непосредственно в ней.
``` go
type Inner struct {
	X int
}

type Outer struct {
	Inner
	X int
}
```
Если вмещающая структура имеет поля или методы с таким же именем, как у встроенного поля, то для обращения к этим затененным полям и методам следует использовать тип встроенного поля. В таком случае можно обратиться к полю X структуры Inner, явно указав имя структуры Inner (типа o.Inner.X))

Встраивание не является наследованием - те нет иерархии.  Вы не можете присвоить переменную типа Manager переменной типа
Employee. Если вам нужно обратиться к полю Employee в структуре Manager, необходимо сделать это явным образом.
``` go
var eFail Employee = m  // ошибка компиляции!
var eOK Employee = m.Employee  // ok!
```

Go не обеспечивает динамическую диспетчеризацию конкретных типов. Методы встроенного поля не знают о том, что они являются встроенными.
Если метод встроенного поля будет вызывать другой метод этого встроенного поля и вмещающая структура будет обладать методом с таким же именем, то метод встроенного поля не будет вызывать метод вмещающей структуры. 

Неявные интерфейсы — единственный абстрактный тип в Go. 
Имя интерфейса обычно оканчивается на *er* (такие интерфейсы состоят из *одного* метода).

Интерфейсы обеспечивают типобезопасную утиную типизацию.

Такое неявное поведение делает интерфейсы самым интересным элементом системы типов языка Go, способным обеспечить типобезопасность в сочетании с низкой связанностью, объединяя возможности и статических, и динамических языков.

Интерфейсы указывают, что требуется вызывающей стороне. Клиентский код определяет интерфейс, чтобы указать, какая функциональность ему нужна.

Наличие стандартного интерфейса дает вам мощные возможности: так, используя в своем коде интерфейсы io.Reader и io.Writer, вы сможете обеспечить корректное чтение и запись вне зависимости от того, с чем именно вы работаете: с файлом на локальном диске или с данными в памяти.

Кроме того, наличие стандартных интерфейсов делает возможным использование паттерна «Декоратор». В Go часто используются фабричные функции, которые принимают экземпляр интерфейса и возвращают другой тип, который реализует тот же интерфейс. 

Если в стандартной библиотеке есть интерфейс, определяющий то, что нужно вашему коду, используйте его!

Ничто не мешает типу, который соответствует интерфейсу, определить дополнительные методы, помимо методов, входящих в интерфейс. Эти методы могут использоваться лишь в определенной части клиентского кода. 

Можно встроить интерфейс в интерфейс.

Опытные Go-разработчики часто рекомендуют принимать интерфейсы и возвращать структуры. Функции должны принимать интерфейсы по причине того, что они делают код более гибким
и явно объявляют, какая именно функциональность используется в функции. При возвращении конкретного типа вы можете добавлять новые методы и поля без нарушения работы существующего кода (Исключением из этого правила являются ошибки. error).

Уменьшение объема памяти, выделяемой в куче, ведет к повышению производительности по причине снижения объема работы, выполняемой сборщиком мусора. Возвращение структуры повзоляет обойтись без выделения памяти в куче, и это очень хорошо. 

Однако при вызове функции с параметрами интерфейсного типа для каждого из этих параметров память выделяется в куче. По мере эксплуатации программы вам нужно будет найти оптимальный баланс между степенью
абстракции и производительностью. Прежде всего, старайтесь сделать свой код читабельным и легко поддающимся сопровождению. Если ваша программа работает слишком медленно и профилирование показывает, что причиной
низкой производительности является выделение памяти в куче для параметра интерфейсного типа, перепишите функцию таким образом, чтобы она использовала параметр конкретного типа. В случае, когда в функцию передается несколько реализаций интерфейса, требуется создание нескольких функций с повторяющейся логикой.

Значение nil также используется для представления нулевого экземпляра интерфейса.
Интерфейс считается равным nil в том случае, когда значению nil равны и тип,и значение.
``` go
var s *string
fmt.Println(s == nil) // выводит true
var i interface{}
fmt.Println(i == nil) // выводит true
i = s
fmt.Println(i == nil) // выводит false
```
В среде выполнения языка Go интерфейсы реализуются как два указателя, один из которых указывает на используемый тип, а другой — на используемое значение. Если тип не равен nil, то и интерфейс не равен nil. (Поскольку у вас не может быть переменной без типа, если указатель на значение не равен nil, то указатель на тип никогда не будет равен nil.) В случае интерфейса значение nil указывает, можно или нет вызывать для него методы. Поскольку, как упоминалось ранее, методы можно вызывать для равных nil экземпляров конкретного типа, в данном случае вполне логично то, что вы можете вызывать методы для переменной интерфейсного типа, которой был присвоен равный nil экземпляр конкретного типа. Если интерфейс равен nil, то вызов для него любых методов приведет к панике.
Если интерфейс не равен nil, то вы можете вызывать для него методы. (Однако имейте в виду, что ваш код может выдать панику и в этом случае, если значение nil будет присвоено типу, методы которого не рассчитаны на обработку значения nil.)

Поскольку экземпляр интерфейса не равен nil , если его тип не равен nil, то очень сложно определить, равно ли nil связанное с интерфейсом значение.

Пустой интерфейс ничего не сообщает (избегать!). Иногда в языке со статической типизацией требуется определенным образом сообщить о том, что переменная может содержать значение любого типа. В Go
для этой цели предназначен пустой интерфейс interface{}
``` go
var i interface{}
i = 20
i = "hello"
```
Пустой интерфейсный тип просто сообщает, что переменная может содержать любое значение, тип которого реализует ноль или более методов.  В частности, он широко используется в качестве
заглушки для данных с неопределенной схемой размещения, считываемых из такого внешнего источника, как файл формата JSON.

По возможности не используйте *пустой интерфейс*, так как  Go — язык со строгой типизацией, и попытки обойти эту его особенность противоречат идиоматическому подходу.

Утверждение типа определяет конкретный тип, который реализовал интерфейс, или другой интерфейс, который также реализуется базовым конкретным типом интерфейса. 
``` go
type MyInt int

var i interface{}
var mine MyInt = 20

i = mine

i2 := i.(MyInt)
fmt.Println(i2 + 1)
```
Здесь переменная i2 обладает типом MyInt.

Что произойдет при некорректном использовании утвер­ждения типа? В таком случае код выдаст панику.
``` go
i2 := i.(string)
fmt.Println(i2)
```
Даже если два типа имеют общий базовый тип, утверждение типа должно соответствовать типу базового значения. 
``` go
i2 := i.(int)
fmt.Println(i2 + 1) // тоже не пройдет (хотя int для MyInt есть базовый)
```
Чтобы не допустить этого, можно воспользоваться идиомой «запятая-ok»,
``` go
i2, ok := i.(int)
if !ok {
	return fmt.Errorf("unexpected type for %v",i)
}
fmt.Println(i2 + 1)
```
Булева переменная ok устанавливается в true в случае успешного преобразования типа. В противном случае переменной ok присваивается значение false, а второй переменной (переменной i2) — соответствующее нулевое значение. Далее внутри оператора if обрабатывается случай получения неожиданного типа.

Между операциями утверждения типа и преобразования типа имеется существенная разница. Операции преобразования типа могут применяться и к конкретным типам, и к интерфейсам и проверяются на этапе компиляции.
Операции утверждения типа могут применяться только к интерфейсным типам и проверяются на этапе выполнения программы. По причине того, что проверка проводится на этапе выполнения, они могут вызвать сбой программы. Операции преобразования типа меняют тип, а операции утверждения типа его раскрывают.

Когда в качестве интерфейса может выступать один из нескольких возможных типов, вместо этого следует использовать переключатель типа:
``` go
func doThings(i interface{}) {
	switch j := i.(type) { // тут могло бы быть затенение если бы не j а i было написано
		case nil:
			// переменная i равна nil, переменная j обладает типом interface{}
		case int:
			// переменная j обладает типом int
		case MyInt:
			// переменная j обладает типом MyInt
		case io.Reader:
			// переменная j обладает типом io.Reader
		case string:
			// переменная j обладает типом string
		case bool, rune:
			// переменная i содержит булево значение или руну,
			// поэтому переменная j обладает типом interface{}
		default:
			// неизвестно, что содержит переменная i, поэтому переменная j
			// обладает типом interface{}
	}
}
```
Поскольку **переключатель типа** служит для получения новой переменной на основе существующей переменной, идиоматический подход сводится к тому, чтобы присвоить переключающую переменную переменной с таким
же именем (i := i.(type)). Это один из тех немногих случаев, где затенение будет вполне уместным. В приведенном выше примере затенение не используется, чтобы сохранить читабельность комментариев.


Используйте утверждения типа и переключатели типа как можно реже. В большинстве случаев параметр или возвращаемое значение следует обрабатывать именно как указанный тип, а не что-то другое. 

Go также позволяет снабжать методами и любые пользовательские типы, включая пользовательские функциональные типы. Это очень полезная возможность, позволяющая функциям
реализовывать интерфейсы. Наиболее широко она используется при создании HTTP-обработчиков. HTTP-обработчик служит для обработки HTTP-запросов и определяется интерфейсом:
``` go
type Handler interface {
ServeHTTP(http.ResponseWriter, *http.Request)
}
```
После преобразования типа в тип http.HandlerFunc любая функция с сигнатурой func(http.ResponseWriter,*http.Request) может быть использована как http.Handler:
``` go
type HandlerFunc func(http.ResponseWriter, *http.Request)
func (f HandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	f(w, r)
}
```
Это позволяет вам реализовывать HTTP-обработчики с помощью функций, методов или замыканий, использующих точно такой же путь выполнения кода, что и в случае других типов, соответствующих интерфейсу
http.Handler.

Функции в Go являются концепциями первого класса и поэтому часто переда­ются функциям в качестве параметров. В то же время Go поощряет использование небольших интерфейсов, и интерфейс, обладающий только одним методом, может заменить параметр функционального типа. 

Когда в качестве входного параметра функции или метода следует использовать функциональный тип, а когда — интерфейс?
Если речь идет о случае, когда одна функция может зависеть от многих других функций или другого состояния, которое не указано в ее входных параметрах, используйте интерфейсный параметр и определите функциональный тип для установления связи между функцией и интерфейсом. Однако если речь идет о простой функции (например, sort.Slice), лучше используйте параметр функционального типа.

Чтобы упростить обеспечение низкой связанности, был разработан ряд методов, один из которых называется внедрением зависимостей. В его основе лежит идея о том, что ваш
код должен явно указывать, какая функциональность ему необходима для выполнения его задачи.

Одно из преимуществ неявных интерфейсов языка Go состоит в том, что они делают внедрение зависимостей очень удобным способом обеспечения низкой связанности кода.

Если поля структуры являются неэкспортируемыми (с маленькой буквы начинаются). Это означает, что они доступны только внутри того пакета, в котором определена эта структура.

Паттерн внедрения зависимостей также позволяет облегчить процесс тестирования, поскольку написание модульных тестов по сути представляет собой повторное использование кода в другой среде, где на входные и выходные данные накладываются определенные ограничения для проверки функциональности.
