Обработка ошибок в Go сводится к возврату значения типа **error** в качестве последнего возвращаемого значения функции. Когда функция выполняется ожидаемым образом, в качестве параметра ошибки возвращается значение nil. Если что-то идет не так, вместо этого возвращается значение ошибки. После этого вызывающая функция проверяет возвращаемое значение ошибки, сравнивая его со значением nil, и об­рабатывает ошибку или возвращает некоторую собственную ошибку. Сообщения об ошибке не должны начинаться с большой буквы и заканчиваться знаком пунктуации или символом новой строки. В большинстве случаев при воз­врате ненулевой ошибки остальным возвращаемым значениям следует присвоить соответствующие нулевые значения.

Тип **error** — это встроенный интерфейс:
``` go
type error interface {
  Error() string
}
```
Любой тип, который реализует этот интерфейс, считается ошибкой. Мы возвра­ щаем значение nil из функции при отсутствии ошибок, потому что значение nil является нулевым значением для интерфейсного типа.

В Go есть тн **сигнальные ошибки**  они сигнализируют о том, что обработка не может продолжаться из-за проблемы с текущим состоянием и обьявляются на уровне пакета. В соответствии с общепринятым
соглашением их имена начинаются на **Err**.  Таике ошибки должны обрабатываться как данные, доступные только для чтения:
``` go
if err == zip.ErrFormat {...}
```

Oшибка, созданная с помощью функции **errors.New**, равна только самой себе или переменным, которым будет явно присвоено ее значение.

Ошибки являются значениями. Поскольку тип **error** представляет собой интерфейс, вы можете определить собственные ошибки с дополнительной информацией для целей журналиро­вания или обработки ошибок. Например, иногда в ошибку требуется включить
код состояния, чтобы указать, какое сообщение выдать пользователю. Это по­зволяет вам при определении причин ошибки обойтись без сравнения строк, содержимое которых может измениться.
``` go
type Status int

const (
  InvalidLogin Status = iota + 1
  NotFound
)

type StatusErr struct {
  Status Status
  Message string
}

func (se StatusErr) Error() string {
  return se.Message
}

func Using() (error) {
  return StatusErr{
    Status: InvalidLogin,
    Message: fmt.Sprintf("invalid credentials for user %s", uid),
  }
}

```
Теперь структуру StatusErr можно использовать для предоставления более подробных сведений о том, что пошло не так.

Всегда стоит возвращать тип **error** в качестве типа возвращаемой ошибки (а не свой, но в других случаях стоит возвращать конкретный тип). Это позволит
возвращать из функции разные типы ошибок, а вызывающая сторона при этом не будет зависеть от конкретного типа ошибок.

При использовании собственного типа ошибки следует позаботиться о том, чтобы функция никогда не возвращала неинициализированный экземпляр.

Применяя пользовательские ошибки, никогда не определяйте переменную с типом вашей пользовательской ошибки. Либо явно возвращайте значе­ние **nil** при отсутствии ошибок, либо определите переменную типа **error** (вот так **var customErr error**).

Для доступа к полям и методам пользовательской ошибки не следует применять **утверждения типа** и **переключатели типа**. Вместо этого задействуйте функцию **errors.As** (о ней ниже..).

Когда ошибка передается в коде в обратном направлении, часто в нее требуется внести дополнительный контекст. Этим контекстом может быть имя функции, в которой произошла ошибка, или сведения о том, какую операцию она пыталась при этом выполнить. Если при добавлении информации исходная ошибка со­храняется, это называют **обертыванием ошибки**. Последовательность обернутых ошибок называется **цепочкой ошибок**. В стандартной библиотеке языка Go есть функция, позволяющая обертывать
ошибки. Функция **fmt.Errorf** поддерживает специ­альный глагол **%w** для создания уточненного сообщения об ошибке, содержащего исходную ошибку. Согласно общепринятому соглашению в конце форматирован­ной строки ошибки следует записать **%w**, чтобы обернуть ошибку, переданную функции **fmt.Errorf** в последнем параметре.
Стандартная библиотека также предоставляет функцию для извлечения обер­нутых ошибок — это функция **Unwrap** из пакета **errors**. Она принимает ошибку и возвращает обернутую ошибку, если такая существует. При отсутствии обер­нутой ошибки она возвращает **nil**:
``` go
func fileChecker(name string) error {
  f, err := os.Open(name)
  if err != nil {
    return fmt.Errorf("in fileChecker: %w", err)
  }
  f.Close()
  return nil
}

func main() {
  err := fileChecker("not_here.txt")
  if err != nil {
    fmt.Println(err)
    if wrappedErr := errors.Unwrap(err); wrappedErr != nil {
      fmt.Println(wrappedErr)
    }
  }
}

// output:
// in fileChecker: open not_here.txt: no such file or directory
// open not_here.txt: no such file or directory
```
Функция **errors.Unwrap** обычно не вызывается напрямую. Для поиска кон­кретной обернутой ошибки лучше воспользоваться функциями **errors.Is** и **errors.As** (о них позже..).

Если вы хотите обернуть ошибку в свой пользовательский тип, ваш тип ошибки должен реализовывать метод **Unwrap**. Он не принимает параметров и возвращает значение типа **error**:
``` go
type StatusErr struct {
	Status  Status
	Message string
	Err     error
}

func (se StatusErr) Error() string {
	return se.Message
}

func (se StatusErr) Unwrap() error {
	return se.Err
}

// Теперь мы можем использовать структуру StatusErr для обертывания базовых ошибок

func Using() error{
	err := errors.New("basic error")
	return StatusErr{
		Status: InvalidLogin,
		Message: fmt.Sprintf("invalid credentials for user %s", "John"),
		Err: err,
	}
}
```

Если вы хотите создать новую ошибку, которая содержала бы сообщение из другой ошибки, не обертывая ее при этом, создайте ошибку с помощью функции **fmt.Errorf**, используя глагол **%v** вместо **%w**:
``` go
err := internalFunction()
if err != nil {
	return fmt.Errorf("internal failure: %v", err)
}
```

Для того, чтобы вернуть несколько ошибок в типе **error** (например при валидации полей пользователя) можно воспользоваться errors.Join(errs...):
``` go
func Using(p Person) error {
	var errs []error
	if len(p.FirstName) == 0 {
		errs = append(errs, errors.New("field FirstName cannot be empty"))
	}
	if len(p.LastName) == 0 {
		errs = append(errs, errors.New("field LastName cannot be empty"))
	}
	if p.Age < 0 {
		errs = append(errs, errors.New("field Age cannot be negative"))
	}
	if len(errs) > 0 {
		return errors.Join(errs...)
	}
	return nil
}
```

Другой способ объединить несколько ошибок — передать несколько глаголов **%w** в **fmt.Errorf**:
``` go
err1 := errors.New("first error")
err2 := errors.New("second error")
err3 := errors.New("third error")
err := fmt.Errorf("first: %w, second: %w, third: %w", err1, err2, err3)
```

Или же можно реализовать свой тип **error**, поддерживающий обертывание нескольких ошибок. Для этого достаточно реализовать метод **Unwrap**, возвраща­ющий **[]error** вместо **error**:
``` go
type MyError struct {
	Code   int
	Errors []error
}

func (m MyError) Error() string {
	return errors.Join(m.Errors...).Error()
}
func (m MyError) Unwrap() []error {
	return m.Errors
}
```

Обратите также внимание, что функция **errors.Unwrap** вернет **nil**, если передать ей ошибку, реализующую вариант Unwrap, возвращающий **[]error**. Это еще одна причина, почему не следует вызывать функцию **error.Unwrap** напрямую.

Если вам приходится обрабатывать ошибки, которые могут содержать ноль, одну или несколько ошибок, то используйте этот код в качестве основы:
``` go
var err error
err = funcThatReturnsAnError()
switch err := err.(type) {        // переключателе типов
case interface {Unwrap() error}:  //  анонимные интерфейсы
	// обработка единственной ошибки
	innerErr := err.Unwrap()
	// обработать innerErr
case interface {Unwrap() []error}:
	// обработка нескольких обернутых ошибок
	innerErrs := err.Unwrap()
	for _, innerErr := range innerErrs {
	// обработать каждую innerErr
	}
default:
	// обработка обычной, не обернутой ошибки
}
```

Обертывание ошибок дает удобный способ передачи дополнительной информа­ции, но в то же время создает определенные проблемы. Вы не сможете проверить наличие сигнальной ошибки с помощью оператора **==**, равно как и применить **утверждение типа** или **переключатель типа** к **пользовательской ошибке**, если она будет обернута. Для решения этой проблемы в пакете **errors** имеется две функции, **Is** и **As**.

Чтобы проверить, не совпадает ли возвращаемая ошибка или какая-либо из за­вернутых в нее ошибок с определенным экземпляром сигнальной ошибки, сле­дует использовать функцию **errors.Is**. Эта функция принимает два параметра: проверяемую ошибку и экземпляр, с которым ее нужно сравнить. Функция **errors.Is** возвращает значение **true**, если в цепи ошибок присутствует ошибка, совпадающая с указанной сигнальной ошибкой. По умолчанию функция errors.Is сравнивает каждую из обернутых ошибок с указанной ошибкой с помощью оператора ==. 
``` go
func main() {
	err := fileChecker("not_here.txt")
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			fmt.Println("That file doesn't exist")
		}
	}
}

func fileChecker(name string) error {
	f, err := os.Open(name)
	if err != nil {
		return fmt.Errorf("in fileChecker: %w", err)
	}
	f.Close()
	return nil
}

// output: That file doesn't exist
```

Но если ваша ошибка является несравни­ваемым типом (те не поддерживает оператор ==), реализуйте метод **Is** для своей ошибки:
``` go
type MyErr struct {
	Codes []int
}
func (me MyErr) Error() string {
	return fmt.Sprintf("codes: %v", me.Codes)
}
func (me MyErr) Is(target error) bool {
	if me2, ok := target.(MyErr); ok {
		return slices.Equal(me.Codes, me2.Codes)
	}
	return false
}
```

С помощью собственного метода **Is** можно выявлять также частичное соот­ветствие с экземпляром ошибки. Иногда требуется сравнить ошибки по маске, указав фильтрующий экземпляр, выявляющий совпадение по некоторым полям. Если требуется, чтобы два экземпляра ошибки **ResourceErr** считались совпада­ющими при совпадении хотя бы одного из полей, это можно сделать, определив свой метод **Is**:
``` go
type ResourceErr struct {
	Resource	string
	Code	int
}

func (re ResourceErr) Error() string {
	return fmt.Sprintf("%s: %d", re.Resource, re.Code)
}

func (re ResourceErr) Is(target error) bool {
	if other, ok := target.(ResourceErr); ok {
		ignoreResource := other.Resource == ""
		ignoreCode := other.Code == 0
		matchResource := other.Resource == re.Resource
		matchCode := other.Code == re.Code
		return matchResource && matchCode ||
			matchResource && ignoreCode ||
			ignoreResource && matchCode
	}
	return false
}

// using:  например, можем найти все ошибки, которые имеют отношение к базе данных, вне зависимости от их кода:
if errors.Is(err, ResourceErr{Resource: "Database"}) {
	fmt.Println("The database is broken:", err)
	// обработка кодов
}
```

Функция **errors.As** позволяет проверить совпадение возвращаемой ошибки (или любой ошибки, завернутой в нее) с определенным типом. Эта функция принимает два параметра: проверяемую ошибку и указатель на переменную искомого типа. Она возвращает значение **true** при наличии в цепи ошибок совпадающей ошибки, которая затем присваивается второму параметру. При отсутствии совпадений в цепи ошибок возвращается значение **false**. Функция **errors.As** сгенерирует панику, если во втором параметре передать
ей не указатель на ошибку или интерфейс, а что-то иное.
``` go
err := AFunctionThatReturnsAnError()
var myErr MyErr  // при помощи var создаем ошибку конкретного типа, равной нулевому значению
if errors.As(err, &myErr) { // затем передаём указатель на неё
	fmt.Println(myErr.Code)
}
```

Во втором параметре функции **errors.As** не обязательно передавать указатель на переменную конкретного типа ошибки — можно передать указатель на интерфейс и найти ошибку, которая соответствует интерфейсу:
``` go
err := AFunctionThatReturnsAnError()

var coder interface {  // здесь мы задействуем анонимный интерфейс, но допускается применение любого интерфейсного типа.
	CodeVals() []int
}

if errors.As(err, &coder) {
	fmt.Println(coder.CodeVals())
}
```
По аналогии с возможностью переопределить стандартную функцию **errors.Is** с помощью своего метода Is есть возможность переопределить и стандартную функцию **errors.As**, определив для своей ошибки метод As. Реализация метода As
является нетривиальной задачей и требует применения рефлексии.  Прибегать к этому следует в исключительных случаях, например, когда требуется выявлять ошибку одного типа и возвращать ошибку другого типа.

Используйте функцию **errors.Is**, когда требуется выявить определенный экземпляр или определенные значения. Если же нужно выявить определенный тип, примените **errors.As**.

В некоторых случаях требуется завернуть в одно и то же сообщение несколько ошибок - это можно сделать при помощи **defer**. Необходимо присвоить имена возвращаемым значениям, чтобы в отложенной
функции была возможность обращаться к переменной **err**. Этот шаблон хорошо подходит для случая, когда требуется обернуть каждую ошибку в одно и то же сообщение. Если нужно настроить обертывающую ошибку для предоставления более подробной контекстной информации о неисправности, то в каждый вызов функции **fmt.Errorf** следует поместить и конкретизированное,и обобщенное сообщение.
``` go
func DoSomeThings(val1 int, val2 string) (_ string, err error) {
	defer func() {  // замыкание, образованное оператором defer
		if err != nil {
			err = fmt.Errorf("in DoSomeThings: %w", err)  //  присваиваем переменной ошибки новую ошибку, которая обертывает исходную ошибку сообщением, указывающим, какая функция обнаружила ошибку.
		}
	}()
	val3, err := doThing1(val1)
	if err != nil {
		return "", err
	}
	val4, err := doThing2(val2)
	if err != nil {
		return "", err
	}
	return doThing3(val3, val4)
}
```

В Go паника (panic) генерируется всякий раз, когда среда выполнения ока­зывается неспособной определить, что следует делать дальше. Если паника возникает в горутине, отличной от основной (те не в main), выполнение цепочки отложенных
функций обрывается на функции, запустившей эту горутину. Программа завершается, если любая горутина сгенерирует панику и не попытается вос­становиться после нее.
Если в ваших программах возникают необратимые ситуации, можете генериро­вать свои паники. Встроенная функция panic принимает один параметр любого типа, но чаще всего ей передаются строки panic("bye!").

Go предоставляет возможность перехватить панику, чтобы выполнить допол­нительные действия перед прекращением работы или вообще обойтись без остановки работы. Для этого нужно внутри оператора defer вызвать встроенную функцию recover и проверить, была ли сгенерирована паника. При наличии пани­ки возвращается присвоенное ей значение. После выполнения функции recover работа продолжается как обычно.
``` go
func div60(i int) {
	defer func() { // в defer регистрируется функция для обработки возможной паники
	if v := recover(); v != nil {  // Вызов функции recover должен производиться внутри оператора defer, поскольку при генерировании паники выполняются только отложенные функции.
		fmt.Println(v)
	}
	}()
	fmt.Println(60 / i)
}

func main() {
	for _, val := range []int{1, 2, 0, 6} {
		div60(val)
	}
}

// output:
60
30
runtime error: integer divide by zero
10 
```

Функция recover не дает нам информации о том, что могло привести к сбою. Она лишь гарантирует, что в случае сбоя мы сможем вывести сообщение и продолжить работу.
