Обобщенные типы (они же дженерики) уменьшают количество повторяющегося кода и повышают типобезопасность.

С помощью обобщенных типов (дженерики) можно написать одну реализацию структуры данных для нескольких типов, и компилятор будет обнаруживать несовместимые данные во время компиляции. 

Дженерики на примере стека (LIFO):
``` go
type Stack[T any] struct {
	items []T
}

func (s *Stack[T]) Push(item T) {
	s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
	if len(s.items) == 0 {
		var zero T
		return zero, false
	}

	top := s.items[len(s.items)-1]
	s.items = s.items[:len(s.items)-1]
	return top, true
}

func main() {
	var intStack Stack[int]
	intStack.Push(3)
	intStack.Push(1)
	intStack.Push(5)
	intStack.Push(2) // [3 1 5 2]

	_, _ = intStack.Pop() // [3 1 5]
}
```
После объявления типа Stack указан параметр типа [T any] заключённый в квадратные скоб­ки. Сначала указывается имя, а следом — ограничение типа (any).  Для определения допустимых типов в Go применяются интерфейсы.
В объявлении методов, как и в объявлении items, используется тип T. В определениях приемника также указан тип Stack[T] вместо Stack. В методе Pop мы не можем просто вернуть nil, потому что это недопустимое значение для значи­мого типа, такого как int. Самый простой способ получить нулевое значение для обобщенного типа сводится к тому, чтобы просто объявить переменную с помо­щью ключевого слова var и вернуть ее, поскольку по определению ключевое слово var всегда инициализирует переменную соответствующим нулевым значением, если ей не присваивается другое значение. При объявлении переменной нужно указать, с каким типом будет работать стек, — в данном случае это тип int. Если мы попытаемся добавить в стек строку, компилятор не позволит нам этого сделать.
