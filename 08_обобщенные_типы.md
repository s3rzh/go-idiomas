**Обобщенные типы** (они же **дженерики**) уменьшают количество повторяющегося кода и повышают типобезопасность.

С помощью обобщенных типов (дженерики) можно написать одну реализацию структуры данных для нескольких типов, и компилятор будет обнаруживать несовместимые данные во время компиляции. 

Дженерики на примере стека (LIFO):
``` go
type Stack[T comparable] struct {
	items []T
}

func (s *Stack[T]) Push(item T) {
	s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
	if len(s.items) == 0 {
		var zero T
		return zero, false
	}

	top := s.items[len(s.items)-1]
	s.items = s.items[:len(s.items)-1]
	return top, true
}

func (s *Stack[T]) Contains(item T) bool {
	for _, v := range s.items {
		if item == v {
			return true
		}
	}
	return false
}

func main() {
	var intStack Stack[int]
	intStack.Push(3)
	intStack.Push(1)
	intStack.Push(5)
	intStack.Push(2)         // [3 1 5 2]
	_ = intStack.Contains(2) // true
	_, _ = intStack.Pop()    // [3 1 5]
	_ = intStack.Contains(2) // false
}
```
После объявления типа Stack указан параметр типа [T comparable] заключённый в квадратные скоб­ки. Сначала указывается имя, а следом — ограничение типа (те comparable).  Для определения допустимых типов в Go применяются интерфейсы.
В объявлении методов, как и в объявлении items, используется тип T. В определениях приемника также указан тип Stack[T] вместо Stack. В методе Pop мы не можем просто вернуть nil, потому что это недопустимое значение для значи­мого типа, такого как int. Самый простой способ получить нулевое значение для обобщенного типа сводится к тому, чтобы просто объявить переменную с помо­щью ключевого слова var и вернуть ее, поскольку по определению ключевое слово var всегда инициализирует переменную соответствующим нулевым значением, если ей не присваивается другое значение. При объявлении переменной нужно указать, с каким типом будет работать стек, — в данном случае это тип int. Если мы попытаемся добавить в стек строку, компилятор не позволит нам этого сделать.

Так же можно создавать **обобщенные функции** - они позволяют абстрагироваться от алгоритмов:
``` go
func Map[T1, T2 any](s []T1, f func(T1) T2) []T2 {
	r := make([]T2, len(s))
	for i, v := range s {
		r[i] = f(v)
	}

	return r
}

func main() {
	words := []string{"One", "Potato", "Two", "Potato"}

	lengths := Map(words, func(s string) int {
		return len(s)
	}) // [3 6 3 6]
}
```

В качестве ограничения типа можно использовать любой интерфейс:
``` go
type Pair[T fmt.Stringer] struct {
	Val1 T
	Val2 T
}
```

Есть также возможность определять интерфейсы, имеющие параметры типа:
```go
type Differ[T any] interface {
	fmt.Stringer
	Diff(T) float64
}

```

Можно использовать **списки типов** для определения операторов:
``` go
type Integer interface {
	int | int8 | int16 | int32 | int64 |
		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
}
```
С помощью списков типов в таких случаях можно указать, какие типы могут передаваться в параметре типа и какие операторы поддерживаются. Списки перечисляют конкретные типы через символ вертикальной черты |.
Если вы хотите, чтобы список типов соответствовал любому пользовательскому типу, созданному на основе базового типа, входящего в список, поставьте перед типами в списке знак тильды (~).


Интерфейс, используемый как параметр типа, может перечислять не только допустимые типы, но и обязательные методы. Например, можно указать, что тип должен иметь базовый тип int и метод String() string:
``` go
type PrintableInt interface {
	~int
	String() string
}
```

Списки типов могут включать не только встроенные простые типы, но и срезы, отображения, массивы, каналы, структуры или даже функции. Они особенно полезны, когда требуется, чтобы параметр типа имел определенный базовый тип и один или несколько методов.
