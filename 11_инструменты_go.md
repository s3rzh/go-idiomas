Команда **go run** создает и запускает двоичный файл из этого временного каталога, а после завершения программы удаляет двоичный файл.

Команда **go install** при­нимает путь к основному пакету в репозитории, за которым следует @ и версия нужного вам инструмента (чтобы получить последнюю версию, вместо номера версии используйте тег @latest), а затем загружает инструмент, компилирует и устанавливает его. По умолчанию go install устанавливает двоичные файлы в подкаталог go/bin в домашнем каталоге. Изменить местоположение можно, указав другой путь в переменной окружения GOBIN. 

Командой **go help environment** можно плучить  список вместе с кратким описанием каждой *переменной окружения*.

Командой **goimports** переформатирует инструк­ции импорта. Она сортирует список импортируемых модулей в алфавитном порядке, удаляет неиспользуемые и пытается угадать, какие еще модули нужно импортировать. Иногда она ошибается, поэтому всегда добавляйте импортируе­мые модули вручную:
**goimports -l -w .**
Флаг -l требует вывести в консоль файлы с неправильным форматированием.
Флаг -w требует исправить файлы на месте. 
А символ точки (.) указывает ката­лог для сканирования, в данном случае будут просканированы текущий каталоги все его подкаталоги.

Команда **staticcheck**  включает более 150 проверок качества кода и ста­рается минимизировать количество ложных срабатываний:
**staticcheck ./...**
После вызова он может выдать, например, следущее main.go:6:7: unnecessary use of fmt.Sprintf (S1039). Повторный вызов **staticcheck -explain S1039** дасть подсказку.

Линтер  **golangci-lint** -  всё в одном. Он обеспечивает максимальную эффективность и способен запускать более 50 инструментов проверки качества кода, включая go vet, staticcheck и revive. Настройте golangci-lint для обнаружения затенения иденти­фикаторов как во всеобщем блоке, так и в собственном коде, поместив следующие строки в конфигурационный файл с именем .golangci.yml в каталоге, где вы запускаете golangci-lint:
``` yml
linters:
  enable:
    - govet
    - predeclared

linters-settings:
  govet:
    check-shadowing:
    settings:
      shadow:
        strict: true
    enable-all: true
```
 Инструмент **govulncheck** сканирует зависимости в поисках известных уязвимостей как в стандарт­
ной библиотеке, так и в сторонних модулях, импортированных в ваш модуль: 
``` bash
$ govulncheck ./...
```
Содержимое файлов можно встроить прямо в двоичный файл программы на Go, используя комментарии **go:embed**.
``` go
import (
  _ "embed"
)

//go:embed passwords.txt
var passwords string
```
Инструмент **go generate** ищет в исходном коде специальные комментарии и запускает указанные в них программы. С помощью go generate можно запускать любые команды, чаще всего этот инструмент ис­
пользуется разработчиками для запуска программ, которые генерируют исходный код. Это могут быть программы, анализи­рующие существующий код и добавляющие дополнительные возможности, или
программы, просматривающие схемы и создающие на их основе исходный код (типа Protocol Buffers, иногда называемый protobufs, — популярный дво­ичный формат, используемый для хранения и передачи данных).

Каждый двоичный файл Go, созданный с помощью go build, содержит информацию о версиях модулей, составляющих двоичный файл, об использованных командах сборки, о системе управления вер­сиями и версии вашего кода. Всю эту информацию можно получить с по­мощью команды **go version -m myapp**.

Программы на Go компилируются в машинный код, поэтому сгенерированный двоичный файл совместим только с одной операционной системой и аппаратной архитектурой. Команда go build упрощает кросс-
компиляцию — создание двоичного файла для другой операционной системы и/или аппаратной архитектуры. Целевую операционную систему и аппаратную архитектуру можно указать в переменных окружения GOOS и GOARCH соответствен­но. Если они не заданы явно, то go build будет использовать значения по умолча­нию, соответствующие применяемому компьютеру **GOOS=linux GOARCH=amd64 go build .**.

Тег сборки, также называемый ограничением сборки - подобно встраиванию контента и генерированию кода, основываются на специальных комментариях, в данном случае //go:build. Этот комментарий должен находиться в строке перед объявлением пакета. Например, //go:build (!darwin && !linux) || (darwin && !go1.12) указывает, что файл не должен компилироваться в Linux или macOS, за исключением случаев, когда компиляция выполняется в macOS с помощью компилятора Go версии 1.11 или ниже. Как альтернатива, можно при компиляци указывать GOOS и GOARCH и называть файлы с суфиксом например myapp_arm64.

В тегах сборки не должно быть пробелов между // и go:build, иначе Go не будет считать их тегами сборки.

Для про­верки, как скомпилируется код на новой или старой версии, можно установить вторичную среду Go. 
``` bash
$ go install golang.org/dl/go1.19.2@latest
$ go1.19.2 download
```
Затем можно использовать:
``` bash
$ go1.19.2 build .
```
После проверки вторичную среду можно удалить среду из каталога sdk и двоичный файл из каталога go/bin.
``` bash
$ rm -rf ~/sdk/go.19.2
$ rm ~/go/bin/go1.19.2
```

**go help** - больше информации об инструментах.
