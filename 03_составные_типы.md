**МАССИВЫ**
 
В Go размер массива считается составной частью его типа. То есть массивы, объявленные с помощью объявлений [3]int и [4]int, будут представлять собой массивы разного типа. Это также означает, что вы не можете использовать переменную для указания размера массива (а const можно!), поскольку типы должны определяться еще на этапе компиляции, а не во время выполнения. Более того, вы не можете использовать преобразование типов для преобразования друг в друга массивов разного размера. Поскольку нельзя преобразовывать друг в друга массивы разного размера.

``` go
var x [3]int
```
Это объявление создает массив из трех элементов типа int. Поскольку значения не были указаны, все элементы (x[0] , x[1] и x[2]) инициализируются нулевыми значениями для типа int, то есть 0.

``` go
var x = [3]int{10, 20, 30}
```
При наличии начальных значений массива их следует указать в литерале массива.

``` go
var x = [12]int{1, 5: 4, 6, 10: 100, 15}
```
В случае разреженного массива (у которого большинство элементов имеют нулевое значение) в литерале массива можно указать только индексы отдельных элементов с соответствующими значениями. Это объявление создает массив из 12 элементов типа int со следующими значениями: [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15].

``` go
var x = [...]int{10, 20, 30}
```
Если массив инициализируется с помощью литерала массива, вместо количества элементов можно поставить многоточие (**...**).

Для сравнения массивов используют операторы сравнения **==** и **!=**
``` go
var x = [...]int{1, 2, 3}
var y = [3]int{1, 2, 3}
fmt.Println(x == y) // выводит true
```

Хотя в Go есть только одномерные массивы, с их помощью можно сымитировать и многомерные массивы:
``` go
var x [2][3]int
```
Этот код объявляет массив x из двух элементов, представляющих собой массивы из трех элементов типа int. 

Для чтения и записи элементов массива в Go используются квадратные скобки:
``` go
x[0] = 10
fmt.Println(x[2])
```

Встроенная функция len принимает на вход массив и возвращает его длину:
``` go
fmt.Println(len(x))
```

Массивы (со всеми своими ограничениями) служат в качестве вспомогательного хранилища для срезов.


**СРЕЗЫ**

Срезы полезны при работе с *последовательными данными* (те перебор). 
При росте срез *копируется сразу* целиком.
Используйте срез, когда *порядок элементов* играет важную роль.

``` go
var x = []int{10, 20, 30}
```
Создается массив из трех элементов типа int с помощью *литерала среза*.

``` go
var x = []int{1, 5: 4, 6, 10: 100, 15}
```
Здесь создается срез из 12 элементов типа int со следующими значениями: [1, 0,0, 0, 0, 4, 6, 0, 0, 0, 100, 15].

``` go
var x [][]int
```
Имитировать многомерные срезы, создавая срезы срезов.

``` go
x[0] = 10
fmt.Println(x[2])
```
Для чтения и записи элементов среза используются квадратные скобки, при этом нельзя выходить за границы среза или использовать отрицательный индекс.

``` go
var x []int
```
Так мы получим срез элементов типа int. Поскольку мы не предоставили никаких значений, срезу x присваивается *нулевое значение*, которым в случае срезов является значение **nil**. 

Значение *nil* языка Go представляет собой идентификатор, представляющий отсутствие значения для ряда типов. Значение *nil не обладает типом*, что позволяет присваивать или сравнивать его со значениями разных типов.
Срез, равный *nil*, не содержит элементов.

Срез является **несравниваемым типом**. Попытка узнать, являются ли два среза одинаковыми, с помощью оператора сравнения **==** или **!=** приведет к ошибке на этапе компиляции. 
Единственное, с чем можно сравнить срез — это значение *nil*:
``` go
fmt.Println(x == nil) // выводит true
```

В пакете reflect есть функция DeepEqual, которая может сравнивать практически все что угодно, включая срезы (В первую очередь она предназначена для тестирования). 

Функция **len** она возвращает 0 при передаче ей среза, равного nil (как и **cap** вернёт 0 тоже).

``` go
var x []int        // такой стиль обявления лучше пододет, когда возможен вариант, что срез так и останется *nil*,
		   // например мы можем вернуть ошибку до любого действия со срезом.
x = append(x, 10)  // добавляем элемент в nil-срез - так можно!
```
Функция **append** используется для увеличения срезов.
Эта функция принимает как минимум два параметра: срез с элементами любого типа и отдельный элемент этого типа. Возвращает она срез того же типа. Возвращаемый срез нужно снова присвоить тому срезу, 
который был передан функции.

или в не nil-срез
``` go
var x = []int{1, 2, 3}  // или даже так var x = []int{} len = 0 cap=0  срез != nil
			// единственным случаем, когда может потребоваться такой срез нулевой длины, является преобразование среза в формат JSON.
x = append(x, 4)
```

или сразу несколько элементов
``` go
x = append(x, 5, 6, 7)
```

Один срез добавляется к другому с помощью оператора **...** (называется **разыменование**)
``` go
y := []int{20, 30, 40}
x = append(x, y...)
```

Если забыть присвоить значение, возвращаемое функцией append, это приведет к *ошибке* на этапе *компиляции*. 

Go используется передача параметров по *значению* (те все копирует!). 
Каждый раз, когда вы передаете параметр функции, Go создает копию передаваемого значения. Поэтому, когда срез передается функции append , на самом деле она получает
его копию.  Функция добавляет значения в копию среза и возвращает ее. После этого возращенный срез нужно снова присвоить (*перезаписать*) той же переменной, которой была передана функции.

Элементам среза выделяются *последовательные* ячейки памяти, что ускоряет чтение и запись этих значений. 
Каждый срез обладает определенной *емкостью*, под чем понимается количество зарезервированных последовательных ячеек памяти.
При каждом добавлении элементов в срез одно или несколько значений добавляются в *конец* среза.
В случае, когда длина превышает ёмкость функция append даст указание среде выполнения языка Go *выделить новый* срез большей емкости. После этого она скопирует значения исходного среза в новый срез, добавит новые значения в его конец и возвратит его в качестве результата.
При увеличении среза с помощью функции append среде выполнения языка Go требуется некоторое время на то, чтобы выделить новую область памяти и скопировать в нее уже имеющиеся данные из старой области памяти. Также нужно освободить старую область памяти с помощью *сборки мусора*.
Начиная с версии Go 1.14, действует следующее правило: емкость среза увеличивается в два раза, пока не начинает превышать 1024, после чего она каждый раз увеличивается минимум на 25 % (в последних версия это так же изменили!!! там есть формула).

Встроенная функция **cap** возвращает текущую емкость среза.

Функции *cap* можно передать и массив, но в таком случае она всегда возвращает то же значение, что и функция *len* (но такой трюк не стоит использовать!!!).

``` go
x := make([]int, 5)
```
Будет гораздо эффективнее один раз задать их размер с помощью функции make.
Этот код создает срез элементов типа int, длина и емкость которого равны 5 (заполненый нулевыми, те *0-ми* в данном случае, значениями).

``` go
x = append(x, 10)
```
В этом случае число 10 добавляется в конец среза, после нулевых значений с индексами 0–4, поскольку функция append всегда увеличивает длину среза. Теперь срез x содержит элементы [0 0 0 0 0 10], 
его длина равна 6, а емкость — 10 (емкость была увеличена в два раза из-за добавления шестого элемента).

``` go
x := make([]int, 5, 10)
```
Функция make также позволяет указать исходную емкость среза. Этот код создает срез элементов типа int длиной 5 и емкостью 10.

``` go
x := make([]int, 0, 10)
```
Можно создать срез с нулевой длиной, но ненулевой емкостью (в данном случаем элементов нет, добавление пойдёт с 0-го индекса).

При создании среза на основе среза копия этих данных *не создается*. На самом деле вы создаете дополнительную переменную, использующую ту же область памяти. Это значит, что изменение элемента среза будет затрагивать все срезы, которые используют этот элемент.

Всякий раз, когда срез создается на основе другого среза, емкость этого подсреза устанавливается равной емкости исходного среза, за вычетом используемого подсрезом смещения внутри исходного среза. Это
значит, что любой подсрез также занимает всю неиспользуемую емкость исходного среза.
``` go
x := make([]int, 0, 10)
y := x[:2:2]  // 2 (крайная правая 2-ка) - 0 (крайняя левая, пусто = 0)
z := x[2:4:4]
```
Здесьи у среза *y*, и у среза *z* емкость равна **2**. Поскольку мы ограничили емкость подсрезов до их длины.

``` go
x := [4]int{5, 6, 7, 8}
y := x[:2]
```
Срезанию могут подвергаться не только срезы, но и массивы для дальненйшего его передачи в функцию. 

``` go
x := []int{1, 2, 3, 4}
y := make([]int, 4)
num := copy(y, x) // а можно и не присваивать copy(y, x)
```
Создать срез так, чтобы он не зависел от исходного среза, используйте встроенную функцию **copy**.
Она копирует из исходного среза в целевой максимально возможное количество элементов, которое определяется размером меньшего среза, и возвращает это количество скопированных элементов. При этом не играет роли емкость срезов x и y: важность представляет лишь их длина.
``` go
x := []int{1, 2, 3, 4}
num = copy(x[:3], x[1:])
fmt.Println(x, num)
```
Функция copy позволяет выполнять копирование между двумя срезами, которые охватывают пересекающиеся области базового среза:
В данном случае последние три элемента среза x копируются в первые три элемента этого среза. На экран будет выведено [2 3 4 4] 3.
``` go
x := []int{1, 2, 3, 4}
d := [4]int{5, 6, 7, 8}
y := make([]int, 2)
copy(y, d[:])
fmt.Println(y) // [5 6]
copy(d[:], x)
fmt.Println(d) // [1 2 3 4]
```
Функцию copy можно использовать и с массивами путем взятия среза в массиве. При этом массив может выступать и в качестве источника, и в качестве цели копирования. 

**СТРОКИ**

Для представления строк в Go используются *последовательности байтов*.

Исходный код программ на этом языке должен всегда записываться в кодировке **UTF-8**.
``` go
var s string = "Hello there"
var b byte = s[6]
```
Можно извлечь одно значение из строки, используя для этого *индексное выражение*. (эту возможность следует использовать только в том случае, когда точно известно, что строка содержит лишь однобайтовые символы.)
``` go
var s string = "Hello there"
var s2 string = s[4:7]
var s3 string = s[:5]
var s4 string = s[6:]
```
Со строками можно использовать и нотацию выражения среза, в данном случае переменной s2 присваивается строка "o t", переменной s3 — строка "Hello", а переменной s4 — строка "there".

Поскольку строки являются *неизменяемыми*, они лишены проблем с модификацией элементов, свойственных срезам срезов.

Размер кодовой точки в кодировке UTF-8 может составлять от одного до четырех байт. 
``` go
var s string = "Hello"
fmt.Println(len(s)) // 5 байт
```
Go позволяет нам узнать длину строки, передав ее встроенной функции **len**.

``` go
var a rune = 'x'
var s string = string(a)
var b byte = 'y'
var s2 string = string(b)
```
Одну руну или один байт можно преобразовать в строку.
``` go
var s string = "Hello тут должен быть смаил солнца!!!"
var bs []byte = []byte(s)
var rs []rune = []rune(s)
fmt.Println(bs)  // [72 101 108 108 111 44 32 240 159 140 158]
fmt.Println(rs)  // [72 101 108 108 111 44 32 127774]
```
Вы можете преобразовать строку в *срез байтов* или *срез рун* и выполнить обратное преобразование.

Для извлечения из строки подстрок и кодовых точек рекомендуется использовать не выражения среза и индекса, а функции из пакетов *strings* и *unicode/utf8* стандартной библиотеки.

**UTF-8** — это наиболее широко используемая кодировка (те бывают и другие) для стандарта *Unicode*.
В этом стандарте (те Unicode) для представления каждой кодовой точки, то есть каждого символа или модификатора, используется 4 байта (32 бита).
кодировка UTF-8 использует один байт для представления символов стандарта Unicode со значениями не выше 128 (что включает в себя буквы, цифры и знаки пунктуации, используемые в английском языке), но расширяется до 4 байт, когда нужно представить кодовые точки стандарта Unicode с более высокими значениями.

**КАРТЫ** (в go 1.24 их переделали)

Тип данных, когда нужно связать одно значение с другим. 
``` go
var nilMap map[string]int // nil-карта
```
Нулевым значением карты является **nil**. 
Карта, равная nil, обладает нулевой длиной (len). 
Попытка *чтения* карты, равной **nil**, всегда возвращает *нулевое значение* того типа, к которому относятся значения карты. 
Однако попытка выполнить *запись* в переменную **nil** карты вызовет **панику**.

``` go
totalWins := map[string]int{}
```
Объявление с помощью оператора **:=** позволяет создать переменную карты путем присвоения ей *литерала карты* (в примере выше  - пустой литерал).
Хотя ее длина тоже равна **0**, для карты, созданной путем присвоения пустого литерала карты, допустимы операции чтения и записи.

``` go
teams := map[string][]string {
"Orcas": []string{"Fred", "Ralph", "Bijou"},
"Lions": []string{"Sarah", "Peter", "Billie"},
"Kittens": []string{"Waldo", "Raul", "Ze"},
}
```
Пример *непустого* литерала карты.

``` go
ages := make(map[int][]string, 10)
```
Если известно сколько будет пар ключ-значение - то можно создать карту с заданным исходным размером, используя функцию make.
Карты, созданные с помощью функции **make**, все равно обладают нулевой длиной и не ограничены в своем росте изначально указанным размером.

При росте карты - она копируется не сразу вся, при помощи *воркеров* во время операций чтения и записи к ней.

Вы можете узнать, сколько пар «ключ — значение» содержится в карте, передав ее функции **len**.

Карты являются несравнимым типом. Вы можете убедиться, что карта не равна значению nil, но вы не проверите, содержат ли две карты одинаковые или разные ключи и значения, используя оператор == или оператор != соответственно.

Ключ карты может быть любого сравнимого типа. Это значит, что в качестве ключей карты нельзя использовать срезы или карты или функции.

Используйте карту, когда порядок элементов не имеет значения.

Используемые в Go карты представляют собой хеш-карту (или хеш-таблицу).
Хеш-карта позволяет быстро извлекать значения по ключу. «За кулисами» это реализуется с помощью массива. При добавлении нового ключа и значения ключ преобразуется в число с помощью алгоритма хеширования.
Этичисла могут повторяться, поскольку алгоритм хеширования может преобразовывать разные ключи в одно и то же число (это называется коллизия). Полученное таким образом число затем используется в качестве индекса массива. 
В качестве элементов массива выступают так называемые бакеты (ведра).  Затем производится сохранение пары «ключ — значение» в ведре. Если ведро уже содержит такой же ключ, то предыдущее значение заменяется новым.
Каждое ведро тоже является массивом (8 элементов) и может содержать несколько значений.

При чтение из хеш-карты указанный ключ нужно преобразовать в число с помощью алгоритма хеширования (хэш функции), найти соответствующее ведро (бакет) и, перебрав все ключи этого ведра, найти среди
них ключ, совпадающий с указанным. При наличии такого ключа возвращается связанное с ним значение.  
Чем больше будет коллизий, тем медленнее будет работать хеш-карта, поскольку при поиске нужного ключа приходится перебирать все ключи, отображенные на одно и то же ведро.

Свести количество коллизий к минимуму можно путем использования хорошо продуманных алгоритмов хеширования. Они меняют размеры хеш-карты после добавления достаточного количества элементов, чтобы обеспечить равномерное заполнение ведер и сделать возможным до-
бавление дополнительных элементов.

GO предоставляет реализацию алгоритмов хеширования для всех типов, выступающих в качестве ключей.
``` go
totalWins := map[string]int{}
totalWins["Orcas"] = 1
totalWins["Lions"] = 2
fmt.Println(totalWins["Orcas"]) // 1
fmt.Println(totalWins["Kittens"]) // 0
totalWins["Kittens"]++
fmt.Println(totalWins["Kittens"]) // 1
totalWins["Lions"] = 3
fmt.Println(totalWins["Lions"]) // 3
```

Если вы попытаетесь прочитать значение ключа, которому еще не было присвоено значение, карта возвратит нулевое значение того типа, к которому относятся значения карты (0 в данном случае тк int), это работает даже в том случае, когда у ключа нет ассоциированного с ним значения.

Идиома «запятая-ok» (или кома-ок)  которая позволяет отличить ключ, с которым связано нулевое значение, от ключа, отсутствующего в карте
``` go
m := map[string]int{
"hello": 5,
"world": 0,
}

v, ok = m["goodbye"]
fmt.Println(v, ok)  // 0, false

delete(m, "hello")
```
Для удаления из карты пар «ключ — значение» используется встроенная функция **delete**.
Если указанного ключа нет в карте или если карта равна **nil** , то ничего не происходит.

Использование карты в качестве множества.
Множество обеспечивает неповторяемость элементов, не давая никаких гарантий в отношении порядка их расположения. Проверка наличия определенного элемента во множестве осуществляется очень быстро,
независимо от количества содержащихся в нем элементов. (В срезе такая проверка начинает занимать больше времени по мере увеличения количества элементов.)
``` go
intSet := map[int]bool{}  // создаем пустую карту (мапу), те проинициализированую и в нее уже можно добавлять.
vals := []int{5, 10, 2, 5, 8, 7, 3, 9, 1, 2, 10}

for _, v := range vals {
intSet[v] = true
}
fmt.Println(len(vals), len(intSet))
fmt.Println(intSet[5])
fmt.Println(intSet[500])
if intSet[100] {
fmt.Println("100 is in the set")
}
```
При попытке обратиться к ней с ключом 500 или 100 она вернет значение false (тк нулевое или дефолтное значение = false).

``` go
intSet := map[int]struct{}{}
vals := []int{5, 10, 2, 5, 8, 7, 3, 9, 1, 2, 10}
for _, v := range vals {
	intSet[v] = struct{}{}
}
if _, ok := intSet[5]; ok {
	fmt.Println("5 is in the set")
}
```
При реализации множества с помощью карты некоторые разработчики
предпочитают использовать в качестве значений пустую структуру: struct{}.
Преимущество такого подхода в том, что пустая структура не занимает ни одного байта, в то время как булево значение занимает один байт.
Если речь не идет о множествах очень большого размера, то разница в объеме занимаемой памяти обычно не настолько значительна для того, чтобы перевешивать эти недостатки.

**СТРУКТУРЫ**

Когда требуется сгруппировать некоторые взаимосвязанные данные, следует определять структуру.
``` go
type person struct {
	name string
	age int
	pet string
}

var fred person
```
Поскольку значение не присваивается переменной fred, она получает нулевое значение для структурного типа person. У структуры, равной нулевому значению, каждое поле содержит
нулевое значение того типа, к которому относится это поле.
``` go
bob := person{} // литерал структуры
```

В структурах нет никакой разницы между присвоением переменной пустого литерала структуры и объявлением переменной без присвоения
значения. И в том и в другом случае все поля структуры будут инициализированы нулевыми значениями соответствующего типа.

``` go
var person struct {
	name string
	age int
	pet string
}
person.name = "bob"
person.age = 50
person.pet = "dog"
```
или такой стиль
``` go
pet := struct {
	name string
	kind string
}{
	name: "Fido",
	kind: "dog",
}
```
Анонимные структуры (не описывая тип, так следует делать когда это структура нужна в одном месте). Одним случаем является преобразование
внешних данных в структуру или, наоборот, структуры во внешние данные (например, данные в формате JSON или буферы протоколов). Эти виды преобразований называют демаршаллингом и маршаллингом данных.
Второй областью применения анонимных структур является написание тестов (например табличных).

Структурный тип может быть сравниваемым или несравниваемым в зависимости от того, к каким типам относятся его поля. Если все поля структуры относятся к сравниваемым типам, то и сама структура является сравниваемой. Если же в качестве некоторых полей используются срезы или карты (или функции и каналы, как мы увидим в последующих главах), то такая структура является несравниваемой.

В Go невозможно сравнивать и переменные, относящиеся к разным структурным типам (например person и animal).  В то же время в Go доступно преобразование
из одного структурного типа в другой, если поля обеих структур обладают одинаковыми именами и типами и расположены в том же порядке. Например:
``` go
type firstPerson struct {
	name string
	age int
}
type secondPerson struct {
	name string
	age int
}
```
Мы можем преобразовать экземпляр типа firstPerson в экземпляр типа secondPerson , используя преобразование типов, но не можем сравнить экземпляр типа firstPerson с экземпляром типа secondPerson, используя оператор ==, поскольку они относятся к разным типам:
``` go
type thirdPerson struct {
	age int
	name string
}
```
Навозможно преобразовать экземпляр типа firstPerson в экземпляр типа thirdPerson , поскольку поля этих структур расположены в разном порядке.
``` go
type fourthPerson struct {
	firstName string
	age int
}
```
Мы не можем преобразовать экземпляр типа firstPerson в экземпляр типа fourthPerson , поскольку у этих структур не совпадают имена полей.
``` go
type fifthPerson struct {
	name string
	age int
	favoriteColor string
}
```
Наконец, мы не преобразуем экземпляр типа firstPerson в экземпляр типа fifthPerson, поскольку у второй структуры есть дополнительное поле.

``` go
type firstPerson struct {
	name string
	age int
}

f := firstPerson{
	name: "Bob",
	age: 50,
}

var g struct {
	name string
	age int
}
// компилируется без проблем — можно использовать операторы = и ==
// между одинаковыми именованными и анонимными структурами
g = f
fmt.Println(f == g)
```
У анонимных структур здесь имеется небольшая дополнительная особенность:
если из двух переменных структурного типа как минимум одна относится к анонимному структурному типу, то их можно сравнивать без преобразования типов, если поля обеих структур обладают одинаковыми именами и типами и расположены в том же порядке. Вы также можете выполнять присваивание между переменными именованного и анонимного структурных типов, если поля обеих структур обладают одинаковыми именами и типами и расположены в том же порядке.
