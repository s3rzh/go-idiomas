Серверам нужна возможность обрабатывать метаданные, относящиеся к отдель­ному запросу. Их можно разделить на две основные категории: необходимые для корректной обработки запроса и указывающие, когда следует прекратить обработку запроса. Например, иногда HTTP-серверу требуется идентификатор отслеживания для идентификации запросов, проходящих по цепочке микро­сервисов. Иногда серверу также требуется установить таймер, прекращающий обработку запросов к другим микросервисам, если они выполняются слишком долго. В Go проблема с метаданными запросов решается с помощью конструкции, называемой контекстом.

Контекст — это экземпляр, который соответствует интерфейсу Context, определенному в пакете context.

Идиоматический подход в Go поощряет явную передачу данных в виде параметров функции. То же относится и к контексту, который передается в функцию явно в первом параметре и называться *ctx*.
Также пакет **context** содержит несколько фабричных функций для создания и обертывания контекстов.

Пустой контекст - создаётся с помощью функции context.Background (или context.TODO - временная заглушка, но в финальном коде её не должно быть!). Она возвращает переменную типа context.Context (это исключение из обще­принятого подхода, согласно которому функция должна возвращать экземпляр конкретного типа). Пустой контекст является отправной точкой, при этом каждое последующее добав­ление метаданных в контекст осуществляется путем обертывания существующего контекста с помощью одной из фабричных функций пакета context.

При обертывании контекст рассма­тривается как неизменяемый экземпляр. Каждое последующее добавление информации в контекст осуществляется путем обертывания имеющегося родительского контекста дочерним контекстом. Это позволяет использовать контексты для передачи информации в более глубокие слои кода. Контекст никогда не применяется для передачи информации из более глубоких слоев наверх.

С помощью метода Value типа context.Context можно проверить наличие значения в контексте или в одном из его родителей. Этот метод принимает ключ и возвращает ассоциированное с ним значение. При этом параметр ключа
и возвращаемое значение опять же объявлены с типом any. Если искомый ключ отсутствует, то метод возвращает nil. Чтобы привести возвращаемое значение к подходящему типу, используйте идиому «запятая-ok»:
``` go
ctx := context.Background()
if myVal, ok := ctx.Value(myKey).(int); !ok {
  fmt.Println("no value")
} else {
  fmt.Println("value:", myVal)
}
```
Поиск значе­ний в цепочке контекстов — это линейный поиск. Это почти не сказывается на производительности, когда нужно найти лишь несколько значений, но может серьезно ухудшить ее, если для каждого запроса в контексте будут сохраняться десятки значений. Однако если ваша программа создает цепочку контекстов с десятками значений, то она, вероятно, нуждается в некотором рефакторинге.

В контексте можно сохранить значение любого типа, но для ключа важно выбрать правильный тип. Как и ключ отображения, ключ сохраняемого в контексте зна­чения должен иметь тип, поддерживающий сравнение. Не используйте простые строки, такие как "id" . Если в качестве типа ключа задействовать строку или другой экспортируемый тип, то в других пакетах можно будет создать идентичные ключи, что приведет к конфликтам. Это вызовет трудно поддающиеся отладке проблемы, как, например, в случае, когда один пакет записывает в контекст дан­ные, маскирующие данные, записанные другим пакетом, или читает из контекста данные, записанные другим пакетом.

Есть два паттерна, гарантирующие уникальность ключа и поддержку сравнения. Первый заключается в создании нового неэкспортируемого типа для ключа на основе int:
``` go
type userKey int

// После объявления неэкспортируемого типа объявляется неэкспортируемая константа этого типа:
const (
  _ userKey = iota
  key
)

// Так как тип и константа будут неэкспортируемыми, никакой внешний код не смо­жет записать данные в контекст с тем же ключом и вызвать конфликт. 
```
Другой вариант — определить неэкспортируемый тип ключа, используя пустую структуру:
``` go
type userKey struct{}
```
Как правильно выбрать стиль ключа в каждом конкретном случае? Если требуется сохранить в контексте набор связанных ключей с различными значениями, ис­пользуйте прием на основе int и iota. Если задействуется только один ключ, то подойдет любой из способов. Важно лишь обеспечить невозможность конфликтов ключей в контексте.

В большинстве случаев вы должны извлекать значение из контекста в своем об­работчике запросов и явно передавать его в свою бизнес-логику. 

В некоторых случаях все же лучше оставить значение в контексте. Один из таких случаев — упоминавшееся ранее применение глобального уникального иденти­ фикатора для отслеживания (те служебная информация). Эта информация используется для управления приложением и не является частью состояния бизнес-логики. Явная передача таких данных внутри программы потребует дополнительных параметров и сде­лает невозможной интеграцию со сторонними библиотеками, разработчики которых не знают, какую метаинформацию вы применяете. Если оставить гло­
бальный уникальный идентификатор в контексте, то он останется незаметным для бизнес-логики, которой не нужно что-либо знать об отслеживании, и будет доступен, когда вашей программе потребуется записать сообщение в журнал или подключиться к другому серверу.

Представьте, что у вас есть запрос, для обработки которого запускается несколько горутин, каждая из которых вызывает определен­ный HTTP-сервис. Если один из этих сервисов вернет ошибку, не позволяющую получить корректный результат, то в продолжении дальнейшей обработки внутри остальных горутин не будет никакого смысла. В таком случае в Go производится отмена горутин, реализуемая посредством контекста. Отменяемый контекст можно создать с помощью функции context.WithCancel,
которая принимает экземпляр типа context.Context и возвращает экземпляры типов context.Context и context.CancelFunc. При этом возвращаемый экзем­пляр context.Context — это дочерний контекст, который обертывает передан­ный в функцию родительский экземпляр context.Context . Экземпляр типа context.CancelFunc — это функция без параметров, которая отменяет контекст, сообщая всему коду, который ожидает возможной отмены, что нужно прекратить обработку. Каждый раз, создавая контекст с привязанной к нему функцией отмены, вы должны вызвать эту функцию по завершении обработки и в случае успешного выполнения, и при возникновении ошибки. Иначе в вашей программе будет про­исходить утечка ресурсов (памяти и горутин), что в итоге приведет к замедлению или прекращению работы программы. Ошибки не будет, если вы вызовете функ­цию отмены несколько раз, поскольку все последующие вызовы после первого не будут производить никаких действий. Самый простой способ гарантировать вызов функции отмены — передать ее оператору defer сразу после получения:
``` go
ctx, cancelFunc := context.WithCancel(context.Background())
defer cancelFunc()
```
Интерфейс context.Context имеет метод Done. Он возвращает канал типа struct{}. (Этот тип выбран потому, что пустая структура не потребляет память.) Данный канал закрывается, когда вызывается функция отмены, а как вы наверняка помните, закрытый канал всегда
возвращает свое нулевое значение при попытке прочитать его.
Вызов метода Done неотменяемого контекста возвращает значение nil . Операция чтения из канала nil никогда не возвращает значение. Если попытать­ся сделать это не внутри ветви case оператора select , то программа зависнет (block).

Для управления своей нагрузкой сервер обычно может сделать следующее:
- ограничить количество одновременных запросов;
- ограничить количество запросов в очереди на выполнение;
- ограничить время выполнения запроса;
- ограничить количество используемых запросом ресурсов, таких как память или дисковое пространство.

Механизм GOMEMLIMIT позволяет ограничить объем памяти, используемой программой в целом. Но если вы решите ограничить объем памяти или дис­кового пространства, задействуемый при обработке запроса, то вам придется написать собственный код для управления этим ресурсом.

Для создания контекста с ограничением по времени можно использовать одну из двух функций. Первая из них, context.WithTimeout, принимает два параметра: существующий контекст и экземпляр типа time.Duration, представляющий про­межуток времени, после которого будет производиться автоматическая отмена контекста. Возвращает эта функция контекст, автоматически запускающий от­мену после указанного промежутка времени, и функцию, которую можно вызвать для немедленной отмены контекста.

Вторая функция, context.WithDeadline , принимает существующий контекст и экземпляр типа time.Time, указывающий, в какой момент времени будет произ­ведена автоматическая отмена контекста. Подобно функции context.WithTimeout, она возвращает контекст, автоматически запускающий отмену в указанный мо­мент времени, и функцию отмены. Если передать функции context.WithDeadline момент времени в прошлом, то она создаст уже отмененный контекст.

По аналогии с функцией отмены, возвращаемой из context.WithCancel или context.WithCancelCause, вы должны хотя бы один раз вызвать функцию отмены (поэтому defer cancel() в main?), возвращаемую из context.WithTimeout и context.WithDeadline.

При этом любой тайм-аут, установленный в дочернем контексте, будет ограни­чен тайм-аутом, установленным в родительском контексте. Таким образом, если длительность тайм-аута будет составлять 2 с в родительском контексте и 3 с в до­чернем контексте, то по истечении 2 с будет произведена отмена и родительского, и дочернего контекста.
``` go
ctx := context.Background()
parent, cancel := context.WithTimeout(ctx, 2*time.Second)
defer cancel()
child, cancel2 := context.WithTimeout(parent, 3*time.Second)
defer cancel2()
start := time.Now()
<-child.Done()
end := time.Now()
fmt.Println(end.Sub(start).Truncate(time.Second))

// output: 2s тк родительский контект раньше отмениться и заэффектит дочерний
```
Чтобы узнать причину - метод  ctx.Err() возвращает nil, если контекст все еще активен, или одну из сигнальных ошибок — context.Canceled или context.DeadlineExceeded, если контекст был отменен. Первый возвращается, если отмена произведена явно, а второй — если отмена произошла автоматически по тайм-ауту.

Чтобы вернуть ошибку, объясняющую причину отмены, оберните контекст, созданный вызовом WithTimeout или WithDeadline, контекстом, созданным вызовом WithCancelCause. Запланируйте вызов обеих функций отмены с помощью оператора defer, чтобы предотвратить утечку ресурсов. Если вы хотите вернуть пользовательскую сигнальную ошибку по истечении тайм-аута контекста, то задействуйте функцию context.WithTimeoutCause или context.WithDeadlineCause.

