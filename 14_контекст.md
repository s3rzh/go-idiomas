Серверам нужна возможность обрабатывать метаданные, относящиеся к отдель­ному запросу. Их можно разделить на две основные категории: необходимые для корректной обработки запроса и указывающие, когда следует прекратить обработку запроса. Например, иногда HTTP-серверу требуется идентификатор отслеживания для идентификации запросов, проходящих по цепочке микро­сервисов. Иногда серверу также требуется установить таймер, прекращающий обработку запросов к другим микросервисам, если они выполняются слишком долго. В Go проблема с метаданными запросов решается с помощью конструкции, называемой контекстом.

Контекст — это экземпляр, который соответствует интерфейсу Context, определенному в пакете context.

Идиоматический подход в Go поощряет явную передачу данных в виде параметров функции. То же относится и к контексту, который передается в функцию явно в первом параметре и называться *ctx*.
Также пакет **context** содержит несколько фабричных функций для создания и обертывания контекстов.

Пустой контекст - создаётся с помощью функции context.Background (или context.TODO - временная заглушка, но в финальном коде её не должно быть!). Она возвращает переменную типа context.Context (это исключение из обще­принятого подхода, согласно которому функция должна возвращать экземпляр конкретного типа). Пустой контекст является отправной точкой, при этом каждое последующее добав­ление метаданных в контекст осуществляется путем обертывания существующего контекста с помощью одной из фабричных функций пакета context.

При обертывании контекст рассма­тривается как неизменяемый экземпляр. Каждое последующее добавление информации в контекст осуществляется путем обертывания имеющегося родительского контекста дочерним контекстом. Это позволяет использовать контексты для передачи информации в более глубокие слои кода. Контекст никогда не применяется для передачи информации из более глубоких слоев наверх.

С помощью метода Value типа context.Context можно проверить наличие значения в контексте или в одном из его родителей. Этот метод принимает ключ и возвращает ассоциированное с ним значение. При этом параметр ключа
и возвращаемое значение опять же объявлены с типом any. Если искомый ключ отсутствует, то метод возвращает nil. Чтобы привести возвращаемое значение к подходящему типу, используйте идиому «запятая-ok»:
``` go
ctx := context.Background()
if myVal, ok := ctx.Value(myKey).(int); !ok {
  fmt.Println("no value")
} else {
  fmt.Println("value:", myVal)
}
```
Поиск значе­ний в цепочке контекстов — это линейный поиск. Это почти не сказывается на производительности, когда нужно найти лишь несколько значений, но может серьезно ухудшить ее, если для каждого запроса в контексте будут сохраняться десятки значений. Однако если ваша программа создает цепочку контекстов с десятками значений, то она, вероятно, нуждается в некотором рефакторинге.

В контексте можно сохранить значение любого типа, но для ключа важно выбрать правильный тип. Как и ключ отображения, ключ сохраняемого в контексте зна­чения должен иметь тип, поддерживающий сравнение. Не используйте простые строки, такие как "id" . Если в качестве типа ключа задействовать строку или другой экспортируемый тип, то в других пакетах можно будет создать идентичные ключи, что приведет к конфликтам. Это вызовет трудно поддающиеся отладке проблемы, как, например, в случае, когда один пакет записывает в контекст дан­ные, маскирующие данные, записанные другим пакетом, или читает из контекста данные, записанные другим пакетом.

Есть два паттерна, гарантирующие уникальность ключа и поддержку сравнения. Первый заключается в создании нового неэкспортируемого типа для ключа на основе int:
``` go
type userKey int

// После объявления неэкспортируемого типа объявляется неэкспортируемая константа этого типа:
const (
  _ userKey = iota
  key
)

// Так как тип и константа будут неэкспортируемыми, никакой внешний код не смо­жет записать данные в контекст с тем же ключом и вызвать конфликт. 
```
Другой вариант — определить неэкспортируемый тип ключа, используя пустую структуру:
``` go
type userKey struct{}
```
Как правильно выбрать стиль ключа в каждом конкретном случае? Если требуется сохранить в контексте набор связанных ключей с различными значениями, ис­пользуйте прием на основе int и iota. Если задействуется только один ключ, то подойдет любой из способов. Важно лишь обеспечить невозможность конфликтов ключей в контексте.
