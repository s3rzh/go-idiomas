Указатель — это просто переменная, содержащая адрес ячейки памяти, в кото-
рой уже размещено реальное значение (например цифра 42).  указатель занимает одно и то же количество ячеек
памяти (фиксировано 8 байт).
Нулевым значением указателей является значение nil. 

Каждая переменная хранится в одной или нескольких последовательных ячей-
ках памяти (1 ячейка - 1 байт (состоит и 8 бит)) с определенными адресами. При этом переменные, относящиеся
к разным типам данных, могут занимать разный объем памяти.

Наличие в Go сборщика мусора позволило устранить практически все
сложные моменты, связанные с управлением памятью. Go нельзя
использовать адресную арифметику (хотя пакет unsafe позволяет это делать на свой страх и риск).

``` go
x := "hello"
pointerToX := &x
```
Символом & обозначается оператор взятия адреса и возвращает адрес ячейки памяти, в которой находится значение.

``` go
x := 10
pointerToX := &x
fmt.Println(pointerToX) // выводит адрес в памяти
fmt.Println(*pointerToX) // выводит 10
```
Символом * обозначается оператор разыменования.  Он ставится перед переменной указательного типа и возвращает то значение, на которое она указывает.
Перед разыменованием указателя необходимо убедиться в том, что он не является нулевым. 
``` go
x := 10
var pointerToX *int
pointerToX = &x
```
Указательный тип служит для представления указателя и обозначается с помо-
щью символа * перед именем типа. Такой тип можно создать на основе любого
типа данных:
``` go
var x = new(int)
fmt.Println(x == nil) // выводит false
fmt.Println(*x)  // выводит 0
```
Встроенная функция new создает переменную указательного типа. Она возвра-
щает указатель на экземпляр нулевого значения для заданного типа.

Оператор &
нельзя использовать перед литералами простых типов (числами, булевыми
значениями и строками) или константами, потому что они не обладают адресом
в памяти и существуют только во время компиляции (нельзя написать &42 или &"Hello world"),
а  следует объявить переменную и создать указывающий на нее указатель. (var y string z := &y).

Когда мы передаем константу (напривем строку) функции, эта константа копируется в параметр, который представляет собой переменную. Эта
переменная уже обладает определенным адресом в памяти и от неё уже можно взять адресс( те &)

Используйте вспомогательную функцию, когда нужно преобразовать кон-
стантное значение в указатель. (типа func(s string) *string {return &s}) 

В большинстве случаев следует использовать значения.  Они облегчают понимание
того, как и когда меняются данные. Еще одно преимущество состоит в том, что
использование значений уменьшает объем работы, выполняемой сборщиком
мусора.

Go — язык с передачей параметров по значению, передаваемые
функциям значения представляют собой копии. В случае таких неуказательных
типов, как простые типы, структуры и массивы, это означает, что вызываемая
функция не может изменить оригинал. Вызываемая функция получает копию
исходных данных, что гарантирует неизменность исходных данных.

Однако при передаче указателя функция получает копию указателя, который
по-прежнему указывает на исходные данные. Это означает, что в таком случае
вызываемая функция может изменить оригинал.

Для возвращения значений из функции старайтесь использовать значимые
типы (те НЕ указательный).

В случае достаточно больших структур использование указателя на структуру
в качестве входного параметра или возвращаемого значения дает некоторый
прирост производительности. Время, необходимое на передачу указателя
функции, является неизменным для данных любых размеров и составляет
приблизительно одну наносекунду. Это вполне логично, поскольку размер
указателя является одинаковым для всех типов данных. Передача функции
значения занимает все больше времени по мере увеличения размера данных
и составляет примерно 1 миллисекунду, когда размер значения доходит до
10 Мбайт.

Возврат указателя дает более любопытный результат, чем возврат значения.
Когда размер структуры данных составляет менее одного мегабайта, возвра-
щение указательного типа вместо значимого на самом деле снижает произво-
дительность. Так, например, возвращение структуры данных размером 100 байт
занимает около 10 наносекунд, а возвращение указателя на такую структуру
данных — около 30 наносекунд. Однако когда размер структуры данных превы-
шает один мегабайт, использование указателей, наоборот, дает положительный
эффект. Таким образом, для возвращения данных размером 10 Мбайт требуется
почти 2 миллисекунды, а для возвращения указателя на такие данные — чуть
больше половины миллисекунды.

Использование указателя является удобным способом обозначения
отсутствия значений, но если вы не собираетесь изменять значение, то вместо
указателя следует использовать значимый тип и булево значение.

При модификации переданной функции карты все изменения отражаются в исходной переменной, которая была
передана функции: это объясняется тем, что в среде выполнения языка Go
карта реализована как указатель на структуру. Передавая карту функции, вы
фактически копируете указатель. По этой причине карты не следует использовать в качестве входных параме-
тров или возвращаемых значений, особенно при создании публичных API.

В то же время при передаче функции среза приходится иметь дело с более
сложным поведением: хотя любое изменение содержимого среза отражается
в исходной переменной, в ней не отражается изменение длины среза с помощью
функции append, даже если емкость среза превышает его длину. Это объясняется
тем, что срез в Go реализован как структура, содержащая три поля: поле типа
int для длины среза, поле типа int для емкости и указатель на блок памяти.
Когда срез копируется в другую переменную или передается функции, создавае-
мая копия включает в себя длину, емкость и указатель. Изменение значений элементов среза ведет к изменениям в той области памяти,
на которую указывает указатель, и потому эти изменения будут видны и в копии,
и в оригинале. Изменение длины и емкости среза не отражается в оригинале, поскольку
при этом изменяется только копия.  Изменение емкости означает, что ука-
затель теперь будет указывать на новый, более крупный блок памяти.
Если в копию среза будут добавлены новые значения и при этом емкость среза
будет достаточной для того, чтобы не выделять новый срез, то длина копии
изменится, а новые значения будут сохранены в блоке памяти, совместно
используемом копией и оригиналом. Однако длина исходного среза при этом
останется неизменной. Это значит, что среда выполнения языка Go не даст
исходному срезу увидеть эти значения, поскольку они находятся за пределами
его длины. В итоге при передаче функции среза вы можете изменить его содержимое,
но не можете изменить его размер. Срезы часто передаются функциям
в Go-программах. При этом по умолчанию предполагается, что срез не должен
изменяться функцией. Вы можете передать функции срез любого размера, потому что при этом
всегда передаются и те же данные: два значения типа int и указатель.
Написать функцию, способную принимать массив любого размера, невозмож-
но, так как при этом передается весь массив, а не только указатель на данные (те он польностью копируется - а это плохо).

Идиоматический подход к написанию Go-кода подразумевает исключение ненужного распределения памяти. 
 Вместо того чтобы выделять новую память при выполнении
каждой операции чтения из источника данных, необходимо один раз создать
срез байтов и использовать его в качестве буфера для чтения из источника
данных:

Использование буферов является лишь одним из примеров снижения объема
работы, выполняемой сборщиком мусора.

Под мусором в программировании
понимаются данные, на которые больше не указывает ни один указатель.

Стек представляет собой непрерывный
блок памяти, который совместно используется всеми вызовами функций в по-
токе выполнения. Выделение памяти в стеке — быстрый и простой процесс.
Указатель стека указывает на то место, где память выделялась в последний
раз, и дополнительная память добавляется путем смещения указателя стека.
В момент вызова функции для ее данных создается новый стековый кадр. В сте-
ке сохраняются локальные переменные и передаваемые функции параметры.
При этом каждая новая переменная смещает указатель стека на длину своего
значения. Когда функция завершает свою работу, возвращаемые ею значения
копируются назад в вызывающую функцию с помощью стека и указатель стека
возвращается в начало стекового кадра для закончившей работу функции, вы-
свобождая ту часть стековой памяти, которая была занята локальными пере-
менными и параметрами этой функции.


Необычной особенностью языка Go является то, что он фактически позво-
ляет увеличить размер стека во время выполнения программы. Это стано-
вится возможным благодаря тому, что каждая горутина обладает собствен-
ным стеком, и управление горутинами осуществляется средой выполнения
языка Go, а не операционной системой. Это дает свои плюсы и минусы.
К плюсам можно отнести то, что стек в Go изначально обладает меньшим
размером и занимает меньше памяти, а к минусам — то, что при увеличении
стека требуется копировать все его содержимое и это отнимает много вре-
мени. При этом в самом худшем случае вы можете написать код, который
будет попеременно заставлять стек расти и уменьшаться.

Чтобы сохранить что-либо в стеке, необходимо точно знать его размер на этапе
компиляции. Если мы взглянем на значимые типы языка Go (простые типы,
массивы и структуры), то увидим, что все они дают четкое представление об
объеме памяти, занимаемой данными на этапе компиляции. Именно поэтому
размер считается частью типа массива. Когда размер известен, можно выделить
память в стеке, а не в куче. По этой причине указатели тоже размещаются в стеке.

Ситуация немного усложняется, когда дело касается данных, на которые ука-
зывает указатель. Для размещения таких данных в стеке должны выполняться
несколько условий. Это должна быть локальная переменная с точно определен-
ным размером содержащихся в ней данных на этапе компиляции. Указатель
при этом не может быть возвращен из функции. Если указатель передается
в функцию, то компилятор по-прежнему должен быть способным проследить
за соблюдением этих условий. Когда размер данных не определен, вы не можете
выделить для них пространство путем простого смещения указателя стека. Если
указатель возвращается из функции, то данные, на которые он указывает, уже не
будут корректными после выхода из функции. Когда компилятор определяет,
что данные, на которые указывает указатель, невозможно разместить в стеке, то
мы говорим, что данные покидают стек и сохраняются в куче.

Куча — это память, управление которой осуществляется сборщиком мусора .
Размещенные в куче данные остаются корректными до тех пор, пока их можно проследить до
размещенной в стеке переменной указательного типа. Когда уже не остается
указателей, указывающих на эти данные (или на данные, указывающие на эти
данные), эти данные становятся мусором, который должен быть удален сбор-
щиком мусора.

Заметив, что функция возвращает
указатель на локальную переменную, он размещает значение этой переменной в куче.

Выполняя escape-анализ (анализ на предмет «убегания» памяти в кучу), ком-
пилятор делает это далеко не идеально. В некоторых случаях данные убегают
в кучу, хотя их можно было бы разместить в стеке. Однако компилятор выну­жден
проявлять сдержанность, поскольку не может допустить того, чтобы в стеке
оказалось значение, которое должно находиться в куче; в противном случае
ссылка на недоступные данные приведет к нарушению целостности данных в памяти. 
С выходом новых релизов языка Go эффективность escape-анализа
постепенно повышается.

Хотя оперативная память и позволяет осуществлять произвольный
доступ, она обеспечивает более высокую скорость при последовательном чте-
нии данных. Срез структур в Go обеспечивает последовательное размещение
данных в памяти, что ускоряет их чтение и обработку. Однако когда мы имеем
дело со срезом указателей на структуры (или со срезом структур, поля которых
являются указателями), данные разбросаны по всей оперативной памяти, что
замедляет их чтение и обработку, а  при произвольном доступе к данным через указатели
скорость снижается примерно на два порядка.

в Go рекомендуется использовать указатели
как можно реже. Тем самым снижается нагрузка на сборщик мусора за счет того,
что максимально возможная часть данных сохраняется в стеке. При использо-
вании срезов структур или простых типов данные располагаются в памяти по-
следовательно, что обеспечивает высокую скорость доступа. А когда сборщик
мусора все же принимается за свою работу, он стремится затратить на нее как
можно меньше времени, вместо того чтобы пытаться собрать как можно больше
мусора. Ключ к повышению эффективности этого подхода в создании меньшего
количества мусора. Хотя кто-то может посчитать такую оптимизацию операций
выделения памяти преждевременной, следует отметить, что для обеспечения
максимальной эффективности в Go достаточно просто придерживаться идио-
матического подхода.
