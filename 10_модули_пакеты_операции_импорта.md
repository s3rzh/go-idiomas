Управление библиотеками в Go основано на трех концепциях, таких как репо­зитории, модули и пакеты. *Репозиторий* - это место в системе управления версиями, где хранится исходный код проекта.
*Модуль* — это комплект исходного кода на Go, который хранится в репозитории и распространяется как единое целое. Каждый модуль включает один или не­ сколько *пакетов* — каталогов с исходным кодом, что придает модулю опреде­ленную структуру.

Для того чтобы можно было использовать код пакетов, не входящих в стандарт­ную библиотеку, каждый проект должен быть объявлен как *модуль*, обладающий глобально уникальным идентификатором. В Go в качестве идентификатора обычно используется путь к репозиторию, в котором находится модуль. Дерево каталогов с исходным кодом на языке Go становится модулем в том случае, если в его корневом каталоге имеется корректный файл **go.mod**.  Команда go mod init ПУТЬ_К_МОДУЛЮ создаст этот файл go.mod. **ПУТЬ_К_МОДУЛЮ** здесь представляет собой глобально уникальное имя, идентифицирующее модуль.

Директива **require** в go.mod присутствуют, только если у вашего модуля есть зависимости и указывается минимальная версия для каждого из них. Первая секция require перечисляет прямые зависимости модуля, вторая — за­висимости зависимостей. 

Оператор **import** позволяет получить доступ к константам, переменным, функциям и типам, экс­портируемым другим пакетом. Доступность идентификаторов за пре­делами пакета, в котором они объявляются, определяется по *регистру* символов. Если идентификатор начинается с буквы верхнего регистра, он *экспортируемый*, а если с буквы нижнего регистра или с символа подчеркивания, то будет доступен только внутри пакета, в котором объявлен.

Имя пакета должно быть *существительным*, описывающим что-то, что создается или изменяется функциями в пакете. Функция или метод что-то делает, поэтому ее/его имя должно быть *глаголом*, отражающим действие.

Иногда бывает нужно импортировать два пакета с одинаковыми именами (например, crypto/rand и math/rand) - для этого в секции import перед одним из них нам стоит задать *alias* с отличным именем.


В качестве имени пакета (alias) можно применять также точку (напрмиер . /somepath/my_pack). При ее использовании все экспортируемые иден­тификаторы из импортируемого пакета переносятся в пространство иментекущего пакета, в результате к ним можно обращаться без префикса (но так делать не нужно).

Имена пакетов могут быть затенены (стоит переопределить имя пакета во избежание конфликта имен). 

В некоторых случаях требуется сделать функ­цию, тип или константу общими для пакетов мо­дуля, не превращая их при этом в часть вашего API. В Go это можно сделать с помощью пакета со специальным именем **internal**. Все идентификаторы, экспортируемые пакетом
internal и его подпакетами, будут доступны только в пакетах одного с ним уровня и в ро­дительском пакете.

Go не допускает наличия *циклических зависимостей* между пакетами. Это значит, что если пакет A прямо или косвенно импортирует пакет B, то пакет B не может прямо или косвенно импортировать пакет A. Если два пакета за­висят друг от друга, то, возможно, их следует объединить в один пакет. Если у вас есть веские основания иметь два отдельных пакета, то, возможно, стоит переместить из одного пакета в другой или в новый пакет только те элементы, которые порождают циклическую зависимость.

Ограничьте зависимости между пакетами.

Если вы определите функцию **init** без входных параметров и возвращаемых значений, она будет вы­ полняться при первом обращении к данному пакету из другого пакета. Поскольку функции init не имеют входных параметров и возвращаемых значений, они
могут лишь производить некоторые побочные эффекты путем взаимодействия с функциями и переменными уровня пакета. По возможности не используйте функцию init.  вы можете определить несколько функций init в одном пакете или даже в одном файле пакета. 

Некоторые пакеты, например пакеты драйверов баз данных, содержат функции init для регистрации драйвера базы данных. При этом не применяется ни один из определенных в пакете идентификаторов, но, как уже упоминалось, в Go нельзя импортировать пакет и затем нигде его не использовать. Чтобы обойти эту проблему, Go предлагает пустой импорт — оператор импорта, в котором в качестве имени пакета указан символ подчеркивания (_). Этот паттерн считается устаревшим, потому что при его использовании неясно,
какая именно операция регистрации выполняется. В настоящее время функции init используются главным образом для инициа­лизации переменных уровня пакета, которые не могут быть настроены с помо­щью одной операции присваивания. Это означает, что любые пере­
менные уровня пакета, настраиваемые с помощью функций init, должны быть фактически неизменяемыми. 

 Go компилирует в один двоичный файл весь код приложения, включая и ваш собственный, и сторонний код.

Сохраняя свои проекты в системе управления версиями, всегда включайте в их состав обновленные файлы go.mod и go.sum . Это позволяет точно указать, какие версии зависимостей используются в вашем коде, а также обеспечивает воспроизводимость сборки: когда кто-то другой (или вы сами в будущем) соберет этот модуль, он получит точно такой же двоичный файл.

Команда go get позволяет работать с модулями, обновляя версии используемых зависимостей.

Чтобы гарантировать, что модуль всегда будет компилироваться с использова­нием одних и тех же зависимостей, некоторые организации предпочитают со­хранять копии применяемых зависимостей внутри своего модуля. Такой подход называется вендорингом. Его можно активизировать с помощью команды **go mod vendor**, которая создает на верхнем уровне модуля каталог vendor, содержащий все его зависимости. После добавления новых зависимостей в файл go.mod или обновления версии существующих зависимостей с помощью команды go get необходимо еще раз выполнить команду go mod vendor, чтобы обновить содержимое каталога vendor.

Семантическое версионирование, принятое в Go, поддерживает концепцию пре-релизов (предварительных версий). Предположим, текущая версия вашего модуля имеет номер v1.3.4. Вы работаете над версией 1.4.0, которая еще не совсем готова,
и хотели бы попробовать импортировать ее в другой модуль. В таком случае в конец тега с номером версии добавьте дефис (-), а затем идентификатор пред­варительной версии, например v1.4.0-beta1 для первой бета-версии версии 1.4.0
или v1.4.0-rc2 для второго кандидата на выпуск. Чтобы добавить зависимость отпредварительной версии, укажите ее явно в команде go get, так как по умолчанию Go не выбирает предварительные версии.

Директива **replace**, которая перенаправляет все ссылки на модуль во всех зависимостях вашего модуля и заменяет их указанной ответвленной версией. Это выглядит так:
replace github.com/jonbodner/proteus => github.com/someone/my_proteus v1.0.0

Вы также можете заблокировать применение определенной версии модуля, на­пример, потому, что она содержит известную ошибку или несовместима с вашим модулем. Для этой цели Go предоставляет директиву **exclude**:
exclude github.com/jonbodner/proteus v0.10.1

Go дает возможность указать версии модуля, которые должны игнорироваться. Это делается добавлением директивы **retract** в файл go.mod вашего модуля:
retract v1.5.0 // не полностью протестирована
retract [v1.7.0, v.1.8.5] // публикует ваши фотографии в LinkedIn без разрешения

Несмотря на кажущееся сходство, директивы retract и exclude имеют очень важное различие. Директива retract запрещает другим использовать опре­деленные версии вашего модуля, а директива exclude блокирует применение
вами версий чужих модулей.

**Рабочее пространство** позволяет загрузить несколько модулей на локальный компьютер и автоматически интерпретировать ссылки на них как локальные ссылки, а не ссылки на код в репозитории.

Вместо того чтобы использовать один централизованный репозиторий для би­блиотек, Go задействует комбинированную модель. Каждый Go-модуль хранится в каком-то репозитории исходного кода, например на GitHub или GitLab. Но по
умолчанию команда go get не извлекает код непосредственно из репозиториев, а отправляет запросы на **прокси-сервер**, поддерживаемый компанией Google. На этом сервере хранятся копии каждой версии практически всех общедоступных Go-модулей. Если модуля или версии модуля нет на прок­си-сервере, то команда go get скачивает его из репозитория модуля, сохраняет копию на сервере и возвращает модуль. Наряду с прокси-сервером компания Google поддерживает базу данных контрольных сумм с информацией о каждой версии каждого модуля, кэшированного прокси сервером. Подобно тому как прокси-сервер защищает нас от пропажи модуля или версии модуля из Интернета, база данных контрольных сумм защищает от моди­фицированных версий модуля. 

