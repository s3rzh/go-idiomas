Управление библиотеками в Go основано на трех концепциях, таких как репо­зитории, модули и пакеты. *Репозиторий* - это место в системе управления версиями, где хранится исходный код проекта.
*Модуль* — это комплект исходного кода на Go, который хранится в репозитории и распространяется как единое целое. Каждый модуль включает один или не­ сколько *пакетов* — каталогов с исходным кодом, что придает модулю опреде­ленную структуру.

Для того чтобы можно было использовать код пакетов, не входящих в стандарт­ную библиотеку, каждый проект должен быть объявлен как *модуль*, обладающий глобально уникальным идентификатором. В Go в качестве идентификатора обычно используется путь к репозиторию, в котором находится модуль. Дерево каталогов с исходным кодом на языке Go становится модулем в том случае, если в его корневом каталоге имеется корректный файл **go.mod**.  Команда go mod init ПУТЬ_К_МОДУЛЮ создаст этот файл go.mod. **ПУТЬ_К_МОДУЛЮ** здесь представляет собой глобально уникальное имя, идентифицирующее модуль.

Директива **require** в go.mod присутствуют, только если у вашего модуля есть зависимости и указывается минимальная версия для каждого из них. Первая секция require перечисляет прямые зависимости модуля, вторая — за­висимости зависимостей. 

Оператор **import** позволяет получить доступ к константам, переменным, функциям и типам, экс­портируемым другим пакетом. Доступность идентификаторов за пре­делами пакета, в котором они объявляются, определяется по *регистру* символов. Если идентификатор начинается с буквы верхнего регистра, он *экспортируемый*, а если с буквы нижнего регистра или с символа подчеркивания, то будет доступен только внутри пакета, в котором объявлен.

Имя пакета должно быть *существительным*, описывающим что-то, что создается или изменяется функциями в пакете. Функция или метод что-то делает, поэтому ее/его имя должно быть *глаголом*, отражающим действие.

Иногда бывает нужно импортировать два пакета с одинаковыми именами (например, crypto/rand и math/rand) - для этого в секции import перед одним из них нам стоит задать *alias* с отличным именем.


В качестве имени пакета (alias) можно применять также точку (напрмиер . /somepath/my_pack). При ее использовании все экспортируемые иден­тификаторы из импортируемого пакета переносятся в пространство иментекущего пакета, в результате к ним можно обращаться без префикса (но так делать не нужно).

Имена пакетов могут быть затенены (стоит переопределить имя пакета во избежание конфликта имен). 

В некоторых случаях требуется сделать функ­цию, тип или константу общими для пакетов мо­дуля, не превращая их при этом в часть вашего API. В Go это можно сделать с помощью пакета со специальным именем **internal**. Все идентификаторы, экспортируемые пакетом
internal и его подпакетами, будут доступны только в пакетах одного с ним уровня и в ро­дительском пакете.

Go не допускает наличия *циклических зависимостей* между пакетами. Это значит, что если пакет A прямо или косвенно импортирует пакет B, то пакет B не может прямо или косвенно импортировать пакет A. Если два пакета за­висят друг от друга, то, возможно, их следует объединить в один пакет. Если у вас есть веские основания иметь два отдельных пакета, то, возможно, стоит переместить из одного пакета в другой или в новый пакет только те элементы, которые порождают циклическую зависимость.
