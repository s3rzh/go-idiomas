Управление библиотеками в Go основано на трех концепциях, таких как репо­зитории, модули и пакеты. *Репозиторий* - это место в системе управления версиями, где хранится исходный код проекта.
*Модуль* — это комплект исходного кода на Go, который хранится в репозитории и распространяется как единое целое. Каждый модуль включает один или не­ сколько *пакетов* — каталогов с исходным кодом, что придает модулю опреде­ленную структуру.

Для того чтобы можно было использовать код пакетов, не входящих в стандарт­ную библиотеку, каждый проект должен быть объявлен как *модуль*, обладающий глобально уникальным идентификатором. В Go в качестве идентификатора обычно используется путь к репозиторию, в котором находится модуль. Дерево каталогов с исходным кодом на языке Go становится модулем в том случае, если в его корневом каталоге имеется корректный файл **go.mod**.  Команда go mod init ПУТЬ_К_МОДУЛЮ создаст этот файл go.mod. **ПУТЬ_К_МОДУЛЮ** здесь представляет собой глобально уникальное имя, идентифицирующее модуль.

Директива **require** в go.mod присутствуют, только если у вашего модуля есть зависимости и указывается минимальная версия для каждого из них. Первая секция require перечисляет прямые зависимости модуля, вторая — за­висимости зависимостей. 

Оператор **import** позволяет получить доступ к константам, переменным, функциям и типам, экс­портируемым другим пакетом. Доступность идентификаторов за пре­делами пакета, в котором они объявляются, определяется по *регистру* символов. Если идентификатор начинается с буквы верхнего регистра, он *экспортируемый*, а если с буквы нижнего регистра или с символа подчеркивания, то будет доступен только внутри пакета, в котором объявлен.

Имя пакета должно быть *существительным*, описывающим что-то, что создается или изменяется функциями в пакете. Функция или метод что-то делает, поэтому ее/его имя должно быть *глаголом*, отражающим действие.

Иногда бывает нужно импортировать два пакета с одинаковыми именами (например, crypto/rand и math/rand) - для этого в секции import перед одним из них нам стоит задать *alias* с отличным именем.


В качестве имени пакета (alias) можно применять также точку (напрмиер . /somepath/my_pack). При ее использовании все экспортируемые иден­тификаторы из импортируемого пакета переносятся в пространство иментекущего пакета, в результате к ним можно обращаться без префикса (но так делать не нужно).

Имена пакетов могут быть затенены (стоит переопределить имя пакета во избежание конфликта имен). 

В некоторых случаях требуется сделать функ­цию, тип или константу общими для пакетов мо­дуля, не превращая их при этом в часть вашего API. В Go это можно сделать с помощью пакета со специальным именем **internal**. Все идентификаторы, экспортируемые пакетом
internal и его подпакетами, будут доступны только в пакетах одного с ним уровня и в ро­дительском пакете.

Go не допускает наличия *циклических зависимостей* между пакетами. Это значит, что если пакет A прямо или косвенно импортирует пакет B, то пакет B не может прямо или косвенно импортировать пакет A. Если два пакета за­висят друг от друга, то, возможно, их следует объединить в один пакет. Если у вас есть веские основания иметь два отдельных пакета, то, возможно, стоит переместить из одного пакета в другой или в новый пакет только те элементы, которые порождают циклическую зависимость.

Ограничьте зависимости между пакетами.

Если вы определите функцию **init** без входных параметров и возвращаемых значений, она будет вы­ полняться при первом обращении к данному пакету из другого пакета. Поскольку функции init не имеют входных параметров и возвращаемых значений, они
могут лишь производить некоторые побочные эффекты путем взаимодействия с функциями и переменными уровня пакета. По возможности не используйте функцию init.  вы можете определить несколько функций init в одном пакете или даже в одном файле пакета. 

Некоторые пакеты, например пакеты драйверов баз данных, содержат функции init для регистрации драйвера базы данных. При этом не применяется ни один из определенных в пакете идентификаторов, но, как уже упоминалось, в Go нельзя импортировать пакет и затем нигде его не использовать. Чтобы обойти эту проблему, Go предлагает пустой импорт — оператор импорта, в котором в качестве имени пакета указан символ подчеркивания (_). Этот паттерн считается устаревшим, потому что при его использовании неясно,
какая именно операция регистрации выполняется. В настоящее время функции init используются главным образом для инициа­лизации переменных уровня пакета, которые не могут быть настроены с помо­щью одной операции присваивания. Это означает, что любые пере­
менные уровня пакета, настраиваемые с помощью функций init, должны быть фактически неизменяемыми. 

 Go компилирует в один двоичный файл весь код приложения, включая и ваш собственный, и сторонний код.

Сохраняя свои проекты в системе управления версиями, всегда включайте в их состав обновленные файлы go.mod и go.sum . Это позволяет точно указать, какие версии зависимостей используются в вашем коде, а также обеспечивает воспроизводимость сборки: когда кто-то другой (или вы сами в будущем) соберет этот модуль, он получит точно такой же двоичный файл.
